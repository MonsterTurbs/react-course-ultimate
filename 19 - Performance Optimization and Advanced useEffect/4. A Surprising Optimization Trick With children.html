

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>React Performance â€” Surprising Optimization Trick with children (Study Guide)</title>
  <style>
    :root{
      --bg:#ffffff;
      --text:#111111;
      --muted:#555555;
      --border:#e6e6e6;
      --soft:#f7f7f7;
      --soft2:#fafafa;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height:1.6;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* Single-column page */
    .page{
      max-width: 860px;
      margin: 0 auto;
      padding: 24px 18px 56px;
    }

    header{
      border-bottom:1px solid var(--border);
      padding-bottom:14px;
      margin-bottom:18px;
    }

    h1{
      font-size: 1.7rem;
      margin: 0 0 6px;
      letter-spacing: .2px;
    }

    .subtitle{
      margin: 0;
      color: var(--muted);
      font-size: .98rem;
    }

    .meta{
      margin-top: 10px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      color:var(--muted);
      font-size:.92rem;
    }

    .chip{
      border:1px solid var(--border);
      background: var(--soft2);
      padding:4px 10px;
      border-radius: 999px;
    }

    h2{
      font-size:1.25rem;
      margin: 20px 0 8px;
    }

    h3{
      font-size:1.05rem;
      margin: 16px 0 8px;
    }

    p{ margin: 10px 0; }

    ul,ol{ margin: 10px 0 10px 22px; }
    li{ margin: 6px 0; }

    .card{
      border:1px solid var(--border);
      background: var(--soft2);
      border-radius: 10px;
      padding: 14px 14px;
      margin: 12px 0;
    }

    .callout{
      border-left: 5px solid var(--border);
      background: var(--soft);
      padding: 12px 12px;
      margin: 12px 0;
      border-radius: 8px;
    }

    .callout strong{ display:inline-block; margin-bottom: 6px; }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    code, pre{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    pre{
      background:#0b0b0b;
      color:#f2f2f2;
      padding: 12px;
      border-radius: 10px;
      overflow:auto;
      margin: 10px 0;
      font-size: .92rem;
      line-height: 1.45;
    }

    .k{
      background: #f0f0f0;
      border: 1px solid var(--border);
      padding: 1px 6px;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: .92rem;
    }

    .printbar{
      display:flex;
      justify-content:flex-end;
      margin: 10px 0 0;
    }

    .btn{
      border:1px solid var(--border);
      background: var(--soft2);
      padding: 8px 12px;
      border-radius: 10px;
      cursor:pointer;
      font-size: .95rem;
    }

    .divider{
      height:1px;
      background: var(--border);
      margin: 18px 0;
    }

    /* Print rules (A4 clean output) */
    @media print{
      @page { size: A4; margin: 16mm; }
      body{ background:#fff; }
      .page{ max-width: none; padding: 0; }
      .printbar{ display:none !important; }
      .card, .callout{ break-inside: avoid; page-break-inside: avoid; }
      pre{ white-space: pre-wrap; word-break: break-word; }
    }
  </style>
</head>
<body>
  <main class="page">
    <header>
      <h1>âš¡ React Performance Trick: Using <span class="k">children</span> to Prevent Re-renders</h1>
      <p class="subtitle">Print-friendly reviewer / study guide (single-column, A4-ready) â€” based on the lecture transcript.</p>
      <div class="meta">
        <span class="chip">ğŸ§  Topic: Preventing wasted renders</span>
        <span class="chip">ğŸ” Tooling: React Profiler</span>
        <span class="chip">ğŸ§© Key idea: Elements passed as props</span>
      </div>
      <div class="printbar">
        <button class="btn" onclick="window.print()">Print / Save as PDF</button>
      </div>
    </header>

    <section>
      <h2>âœ… What you will learn</h2>
      <div class="card">
        <ul>
          <li>Why a slow child component re-renders when a parent state changes (even if the child doesnâ€™t use that state).</li>
          <li>The â€œsurprisingâ€ optimization: pass the slow subtree as <span class="k">children</span> (or another prop) to avoid re-rendering it.</li>
          <li>How to confirm the behavior using the React Profiler.</li>
          <li>Why this also explains a common context/provider behavior (children may not re-render).</li>
        </ul>
      </div>
    </section>

    <section>
      <h2>ğŸ§© The setup used in the lecture</h2>
      <p>
        The lecture uses a test component with a counter and a <strong>SlowComponent</strong>.
        The SlowComponent simulates expensive rendering by creating a massive array (e.g., <strong>100,000 words</strong>) and rendering it.
      </p>

      <div class="callout">
        <strong>ğŸ§ª Why this matters</strong>
        <p>
          If a component is slow to render, re-rendering it unnecessarily can cause visible UI lag (e.g., button clicks feel delayed).
        </p>
      </div>

      <h3>Symptoms</h3>
      <ul>
        <li>Clicking the counter button feels delayed (e.g., ~0.5s).</li>
        <li>The delay happens because the expensive child re-renders on every parent state update.</li>
      </ul>
    </section>

    <section>
      <h2>ğŸ§  Why the slow component re-renders in the first place</h2>
      <p>
        In React, when a component instance re-renders, React will also re-render its child components by default.
        So if your counter updates state, the counter component re-renders, and the SlowComponent (as a child) also re-renders.
      </p>

      <div class="card">
        <h3>Key point (very important)</h3>
        <ul>
          <li>Even if SlowComponent doesnâ€™t <em>use</em> the counter state, it still re-renders because it is part of the parentâ€™s output tree.</li>
          <li>This can cause <strong>wasted renders</strong> and noticeable lag when the child is expensive.</li>
        </ul>
      </div>
    </section>

    <section>
      <h2>âš¡ The optimization trick: pass the slow subtree as <span class="k">children</span></h2>
      <p>
        Instead of rendering <span class="k">&lt;SlowComponent /&gt;</span> directly inside the counter, you refactor the counter to render
        <span class="k">children</span>.
      </p>

      <div class="card">
        <h3>Before (slow): SlowComponent is directly inside Counter</h3>
        <pre><code>// Before: Counter re-renders âœ SlowComponent also re-renders
function Test() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;h1&gt;Test&lt;/h1&gt;
      &lt;button onClick={() =&gt; setCount(c =&gt; c + 1)}&gt;{count}&lt;/button&gt;
      &lt;SlowComponent /&gt;
    &lt;/div&gt;
  );
}</code></pre>

        <h3>After (fast): SlowComponent is passed as children</h3>
        <pre><code>// After: SlowComponent is created outside Counter and passed in
function Counter({ children }) {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setCount(c =&gt; c + 1)}&gt;{count}&lt;/button&gt;
      {children}
    &lt;/div&gt;
  );
}

function Test() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Test&lt;/h1&gt;
      &lt;Counter&gt;
        &lt;SlowComponent /&gt;
      &lt;/Counter&gt;
    &lt;/div&gt;
  );
}</code></pre>
      </div>

      <div class="callout">
        <strong>âœ… Result</strong>
        <p>
          Button updates become instant, because Counter re-renders, but SlowComponent does not.
        </p>
      </div>
    </section>

    <section>
      <h2>ğŸ” Why this works (the internal React insight)</h2>
      <div class="card">
        <p>
          When you pass <span class="k">&lt;SlowComponent /&gt;</span> as <span class="k">children</span>, React creates that element
          <strong>before</strong> Counter re-renders.
        </p>
        <ul>
          <li>On initial render, React creates the SlowComponent element and passes it into Counter as a prop.</li>
          <li>When Counter state changes, Counter re-rendersâ€¦ but the <span class="k">children</span> prop still points to the same element.</li>
          <li>Since that element was already created and cannot have changed due to Counterâ€™s state update, React can â€œbail outâ€ and avoid re-rendering it.</li>
        </ul>
      </div>

      <div class="callout">
        <strong>âš ï¸ Important nuance</strong>
        <p>
          This is not â€œmagic caching.â€ Itâ€™s a consequence of <em>where</em> the element is created.
          If the element is created outside the stateful component, it will not be recreated by that state update.
        </p>
      </div>
    </section>

    <section>
      <h2>ğŸ“Š How to prove it: React Profiler</h2>
      <ol>
        <li>Open React DevTools â†’ <strong>Profiler</strong>.</li>
        <li>Click <strong>Record</strong>.</li>
        <li>Click the counter button a few times.</li>
        <li>Stop recording.</li>
      </ol>

      <div class="card">
        <h3>Expected observation</h3>
        <ul>
          <li><strong>Counter</strong> renders (it owns the state).</li>
          <li><strong>SlowComponent</strong> does <em>not</em> render (it was passed in as children and remained unchanged).</li>
        </ul>
      </div>
    </section>

    <section>
      <h2>ğŸ§© Same idea explains a context/provider behavior</h2>
      <p>
        The lecture points out an interesting follow-up: sometimes youâ€™ll see that certain components inside a provider
        do <em>not</em> re-render when the provider updates.
      </p>

      <div class="card">
        <p>
          If components are passed into a provider as <span class="k">children</span>, then they were created before the providerâ€™s internal state update.
          So React can avoid re-rendering them <strong>unless</strong> they subscribe to the providerâ€™s context.
        </p>
        <ul>
          <li>âœ… Child does <strong>not</strong> consume the context â†’ can remain unchanged and skip re-render.</li>
          <li>ğŸ” Child <strong>does</strong> consume the context â†’ it will re-render due to <strong>context change</strong>.</li>
        </ul>
      </div>

      <div class="callout">
        <strong>ğŸ” Profiler interpretation tip</strong>
        <p>
          If a component re-renders because it consumes context, the Profiler will typically show â€œcontext changed,â€ not â€œparent rendered.â€
        </p>
      </div>
    </section>

    <section>
      <h2>âœ… Practical guidance: when to use this trick</h2>
      <div class="grid">
        <div class="card">
          <h3>Use it when</h3>
          <ul>
            <li>You have a <strong>slow subtree</strong> inside a component that frequently updates state.</li>
            <li>The slow subtree does <strong>not</strong> depend on that state.</li>
            <li>You want a quick structural refactor without introducing memoization complexity.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Avoid / reconsider when</h3>
          <ul>
            <li>The â€œchildâ€ actually needs the parentâ€™s state (then it must re-render or receive updated props).</li>
            <li>The refactor makes the code harder to understand than alternatives (e.g., <span class="k">memo</span>, <span class="k">useMemo</span>, <span class="k">useCallback</span>).</li>
            <li>You are using this everywhere â€œjust in caseâ€ (optimize where profiling shows a real problem).</li>
          </ul>
        </div>
      </div>
    </section>

    <section>
      <h2>ğŸ§  Quick recap (memorize this)</h2>
      <div class="card">
        <ul>
          <li>ğŸ‘ª Parent re-render normally implies child re-render.</li>
          <li>ğŸ§± If a subtree is created outside the stateful component and passed as <span class="k">children</span> (or another prop), it may not be recreated on that state update.</li>
          <li>ğŸ“‰ That can eliminate expensive wasted renders.</li>
          <li>ğŸ“Š Always verify with the Profiler, not by â€œfeeling.â€</li>
        </ul>
      </div>

      <div class="divider"></div>
      <p class="subtitle">
        End of study guide â€” next lectures typically continue with more optimization tools (e.g., memo, useMemo, useCallback, etc.).
      </p>
    </section>
  </main>
</body>
</html>
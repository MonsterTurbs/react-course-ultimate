

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced React Patterns ‚Äî Detecting a Click Outside the Modal (Study Guide)</title>
  <style>
    /* =========================
       Print-friendly, A4-ready
       Single-column layout
       ========================= */
    :root {
      --bg: #ffffff;
      --text: #111111;
      --muted: #555555;
      --border: #e6e6e6;
      --soft: #f7f7f7;
      --chip: #f2f4f7;
      --code-bg: #f5f5f5;   /* light gray */
      --code-text: #111111; /* optional: make text dark */
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.6;
      overflow-wrap: anywhere;
      word-break: break-word;
      text-rendering: optimizeLegibility;
    }

    /* Page container */
    .page {
      max-width: 860px;
      margin: 0 auto;
      padding: 28px 20px 48px;
    }

    header {
      padding: 18px 18px 14px;
      border: 1px solid var(--border);
      background: #fff;
    }

    .title {
      margin: 0 0 6px;
      font-size: 26px;
      letter-spacing: 0.2px;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }

    .meta {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      display: inline-block;
      padding: 6px 10px;
      border: 1px solid var(--border);
      background: var(--chip);
      border-radius: 999px;
      font-size: 12px;
      color: #222;
      white-space: nowrap;
    }

    main { margin-top: 18px; }

    section {
      border: 1px solid var(--border);
      background: #fff;
      padding: 16px 18px;
      margin: 14px 0;
    }

    h2 {
      margin: 0 0 10px;
      font-size: 18px;
    }

    h3 {
      margin: 14px 0 8px;
      font-size: 15px;
    }

    p { margin: 10px 0; }

    ul, ol {
      margin: 8px 0 10px 20px;
      padding: 0;
    }

    li { margin: 6px 0; }

    .note {
      border-left: 4px solid #c9d6ff;
      background: var(--soft);
      padding: 10px 12px;
      margin: 10px 0;
    }

    .warn {
      border-left: 4px solid #ffd2a8;
      background: #fff7ef;
      padding: 10px 12px;
      margin: 10px 0;
    }

    .ok {
      border-left: 4px solid #bfecc8;
      background: #f3fff6;
      padding: 10px 12px;
      margin: 10px 0;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .callout-title {
      font-weight: 700;
      margin-bottom: 6px;
    }

    code, pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    pre {
      margin: 10px 0;
      padding: 12px 12px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.12);
      background: var(--code-bg);
      color: var(--code-text);
      overflow: visible; /* allow wrapping */
      white-space: pre-wrap;
      word-break: break-word;
      overflow-wrap: anywhere;
      tab-size: 2;
    }

    .kbd {
      display: inline-block;
      padding: 2px 6px;
      border: 1px solid var(--border);
      border-bottom-width: 2px;
      border-radius: 6px;
      background: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
    }

    .two-col {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .divider {
      height: 1px;
      background: var(--border);
      margin: 14px 0;
    }

    footer {
      margin-top: 18px;
      color: var(--muted);
      font-size: 12px;
    }

    /* =========================
       Print rules
       ========================= */
    @page {
      size: A4;
      margin: 14mm;
    }

    @media print {
      body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
      .page { max-width: none; padding: 0; }
      section, header {
        break-inside: avoid;
        page-break-inside: avoid;
      }
      a, a:visited { color: inherit; text-decoration: none; }
      a[href]::after { content: ""; }
    }
  </style>
</head>

<body>
  <div class="page">
    <header>
      <h1 class="title">üß† Detecting a Click Outside the Modal (React)</h1>
      <p class="subtitle">Study Guide / Reviewer ‚Äî Advanced React Patterns: improving a compound modal with outside-click detection + a reusable custom hook.</p>
      <div class="meta">
        <span class="chip">üìå Topic: Modal UX</span>
        <span class="chip">ü™ù Hooks: useEffect, useRef</span>
        <span class="chip">üß© Pattern: Reusable custom hook</span>
        <span class="chip">‚öôÔ∏è Detail: Event capturing vs bubbling</span>
      </div>
    </header>

    <main>
      <section>
        <h2>üéØ Goal</h2>
        <p>
          Implement a common UI behavior: <strong>when the modal is open, clicking outside the modal window closes it</strong>.
        </p>
        <div class="ok">
          <div class="callout-title">‚úÖ Expected behavior</div>
          <ul>
            <li>Click inside the modal ‚Üí modal stays open.</li>
            <li>Click outside the modal (overlay/background) ‚Üí modal closes.</li>
          </ul>
        </div>
      </section>

      <section>
        <h2>üß© Key Idea (Beginner-friendly)</h2>
        <p>
          We attach a <strong>document-level click listener</strong>. Then we ask:
          ‚ÄúDid the click happen <em>inside</em> the modal element?‚Äù
        </p>
        <p>
          To answer that reliably, we need a reference (ref) to the modal DOM element:
        </p>
        <ul>
          <li>Use <code>useRef()</code> to get a container reference.</li>
          <li>Attach it using <code>ref={ref}</code> on the modal wrapper.</li>
          <li>In the click handler, test <code>ref.current.contains(e.target)</code>.</li>
        </ul>

        <div class="note">
          <div class="callout-title">üí° Mental model</div>
          <p>
            <strong>contains()</strong> answers: ‚ÄúIs the clicked element somewhere inside the modal?‚Äù
            If not, we call <code>close()</code>.
          </p>
        </div>
      </section>

      <section>
        <h2>üõ† Step-by-step Implementation</h2>
        <ol>
          <li>Create a <strong>ref</strong> for the modal container.</li>
          <li>Use <strong>useEffect</strong> to register a document click handler.</li>
          <li>Inside the handler, close the modal if the click is outside.</li>
          <li>Cleanup: remove the listener on unmount (important!).</li>
        </ol>

        <h3>1) Add the ref to the modal container</h3>
        <pre>// inside your Window component (or where the modal DOM is)
import { useEffect, useRef } from "react";

function Window({ children /* ... */ }) {
  const ref = useRef(null);

  return (
    <StyledModal ref={ref}>
      {children}
    </StyledModal>
  );
}</pre>

        <h3>2) Add the document click listener</h3>
        <pre>useEffect(() => {
  function handleClick(e) {
    // If ref exists AND the clicked target is NOT inside modal
    if (ref.current && !ref.current.contains(e.target)) {
      close();
    }
  }

  document.addEventListener("click", handleClick, true);

  return () => {
    document.removeEventListener("click", handleClick, true);
  };
}, [close]);</pre>

        <div class="warn">
          <div class="callout-title">‚ö†Ô∏è Why the third argument <code>true</code>?</div>
          <p>
            <strong>Events bubble</strong>. Without capturing, a click on the ‚ÄúOpen modal‚Äù button can:
            open the modal and then immediately be detected as ‚Äúoutside the modal,‚Äù closing it again.
          </p>
          <p>
            Using <code>true</code> makes the listener run in the <strong>capturing phase</strong> (as the event travels down),
            preventing the ‚Äúopen then instantly close‚Äù problem.
          </p>
        </div>
      </section>

      <section>
        <h2>üîç Common Bugs & Fixes</h2>
        <div class="two-col">
          <div class="note">
            <div class="callout-title">üêõ Bug: ‚Äúcontains is not a function‚Äù</div>
            <p>
              The correct method name is <strong>contains</strong> (with an <code>s</code>), not <code>contain</code>.
            </p>
            <pre>// ‚úÖ correct
ref.current.contains(e.target)

// ‚ùå wrong
ref.current.contain(e.target)</pre>
          </div>

          <div class="note">
            <div class="callout-title">üêõ Bug: ‚ÄúReact Hook useEffect is called conditionally‚Äù</div>
            <p>
              Hooks must run in the same order on every render.
              Don‚Äôt place <code>useEffect</code> inside <code>if</code> blocks.
            </p>
            <pre>// ‚úÖ OK
useEffect(() => { /* ... */ }, []);

// ‚ùå Not allowed
if (isOpen) {
  useEffect(() => { /* ... */ }, []);
}</pre>
          </div>
        </div>
      </section>

      <section>
        <h2>üß∞ Extract to a Reusable Custom Hook: <code>useOutsideClick</code></h2>
        <p>
          Once the logic works, extract it into a custom hook to make it reusable for:
          <strong>modals, dropdowns, tooltips, context menus</strong>, etc.
        </p>

        <h3>‚úÖ Hook API (simple)</h3>
        <ul>
          <li><strong>Input:</strong> a <code>handler()</code> function (what to do when outside click happens).</li>
          <li><strong>Optional:</strong> <code>listenCapturing</code> boolean (defaults to <code>true</code>).</li>
          <li><strong>Output:</strong> a <code>ref</code> to attach to the element you want to protect.</li>
        </ul>

        <h3>Full hook code</h3>
        <pre>// /src/hooks/useOutsideClick.js
import { useEffect, useRef } from "react";

export function useOutsideClick(handler, listenCapturing = true) {
  const ref = useRef(null);

  useEffect(() => {
    function handleClick(e) {
      if (!ref.current) return;
      if (ref.current.contains(e.target)) return;

      handler?.(e);
    }

    document.addEventListener("click", handleClick, listenCapturing);

    return () => {
      document.removeEventListener("click", handleClick, listenCapturing);
    };
  }, [handler, listenCapturing]);

  return ref;
}</pre>

        <h3>Using the hook inside your modal Window</h3>
        <pre>// inside Window
import { createPortal } from "react-dom";
import { useOutsideClick } from "../hooks/useOutsideClick";

function Window({ children, name }) {
  const { openName, close } = useContext(ModalContext);

  const ref = useOutsideClick(close, true);

  if (name !== openName) return null;

  return createPortal(
    <Overlay>
      <StyledModal ref={ref}>
        <Button onClick={close} aria-label="Close modal">√ó</Button>
        <div>{children}</div>
      </StyledModal>
    </Overlay>,
    document.body
  );
}</pre>

        <div class="ok">
          <div class="callout-title">‚úÖ Benefit</div>
          <p>
            The modal stays clean, while the outside-click logic becomes reusable across the app.
          </p>
        </div>
      </section>

      <section>
        <h2>üß™ Quick Self-Check (Mini Quiz)</h2>
        <ol>
          <li>Why do we need a <code>ref</code> for the modal container?</li>
          <li>What does <code>ref.current.contains(e.target)</code> check?</li>
          <li>Why can a modal ‚Äúopen and instantly close‚Äù without capturing?</li>
          <li>What does the third argument of <code>addEventListener</code> do?</li>
          <li>What does a custom hook return in this case, and why?</li>
        </ol>

        <div class="note">
          <div class="callout-title">‚úÖ Answers (short)</div>
          <ul>
            <li>To know which DOM element is ‚Äúinside‚Äù the modal.</li>
            <li>If the click happened inside the modal tree.</li>
            <li>Because events bubble and the open-click is also seen by the document handler.</li>
            <li>Switches between bubbling (<code>false</code>) and capturing (<code>true</code>).</li>
            <li>A <code>ref</code>, so the caller can attach it to the protected element.</li>
          </ul>
        </div>
      </section>

      <section>
        <h2>üìå Practical Tips</h2>
        <ul>
          <li>Always cleanup event listeners in <code>useEffect</code> to avoid memory leaks.</li>
          <li>Prefer capturing for outside-click modals to avoid the ‚Äúinstant close‚Äù issue.</li>
          <li>Keep your modal component focused on UI; extract generic behavior into hooks.</li>
          <li>Consider also handling <strong>Escape key</strong> to close modals (common UX).</li>
        </ul>
      </section>

      <footer>
        <div class="divider"></div>
        <p>
          Print tip: Use your browser‚Äôs Print dialog and select A4 with default margins. This page is already optimized for clean printing.
        </p>
      </footer>
    </main>
  </div>
</body>
</html>
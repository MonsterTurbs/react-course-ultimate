

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>React Reviewer â€” Managing State with useReducer</title>
  <style>
    :root{
      --bg:#ffffff;
      --text:#111111;
      --muted:#555555;
      --border:#e6e6e6;
      --soft:#f7f7f8;
      --soft2:#fbfbfc;
      --accent:#0b57d0;
      --ok:#0f766e;
      --warn:#b45309;
      --bad:#b91c1c;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:var(--sans);
      line-height:1.55;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* Single-column page */
    .page{
      max-width: 900px;
      margin: 0 auto;
      padding: 28px 22px 40px;
    }

    header{
      border:1px solid var(--border);
      background: linear-gradient(180deg, var(--soft2), var(--bg));
      border-radius: 14px;
      padding: 18px 18px 14px;
    }

    h1{
      margin:0 0 6px;
      font-size: 1.55rem;
      letter-spacing: .2px;
    }
    .subtitle{
      margin:0;
      color:var(--muted);
      font-size:.98rem;
    }

    .meta{
      margin-top:12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      background:var(--bg);
      color:var(--muted);
      font-size:.9rem;
      white-space:nowrap;
    }

    main{ margin-top: 18px; }

    h2{
      margin: 22px 0 10px;
      font-size: 1.25rem;
    }

    h3{
      margin: 16px 0 8px;
      font-size: 1.05rem;
    }

    p{ margin: 8px 0; }

    .callout{
      border:1px solid var(--border);
      border-left-width: 6px;
      border-radius: 12px;
      padding: 12px 14px;
      background: var(--soft2);
      margin: 12px 0;
    }
    .callout.ok{ border-left-color: var(--ok); }
    .callout.warn{ border-left-color: var(--warn); }
    .callout.bad{ border-left-color: var(--bad); }

    .kicker{
      font-weight: 700;
      margin:0 0 6px;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .kicker small{ font-weight:600; color:var(--muted); }

    ul,ol{ margin: 8px 0 8px 22px; }
    li{ margin: 6px 0; }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .box{
      border:1px solid var(--border);
      background: var(--bg);
      border-radius: 12px;
      padding: 12px 14px;
    }

    .box h3{ margin-top: 0; }

    code, pre{ font-family: var(--mono); }

    pre{
      margin: 10px 0;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--soft);
      overflow:auto;
      font-size: .92rem;
      line-height: 1.45;
      tab-size: 2;
      white-space: pre;
    }

    .inline{
      font-family: var(--mono);
      background: var(--soft);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1px 6px;
      font-size: .92em;
    }

    .diagram{
      border: 1px dashed var(--border);
      border-radius: 12px;
      background: #fff;
      padding: 12px;
    }

    .diagram pre{
      background: transparent;
      border: none;
      margin: 0;
      padding: 0;
      overflow: visible;
      white-space: pre-wrap;
    }

    table{
      width:100%;
      border-collapse: collapse;
      margin: 10px 0;
      font-size: .95rem;
    }
    th, td{
      border:1px solid var(--border);
      padding: 10px 10px;
      vertical-align: top;
    }
    th{
      background: var(--soft);
      text-align:left;
      font-weight: 700;
    }

    .hr{
      height:1px;
      background: var(--border);
      margin: 18px 0;
    }

    .footer{
      margin-top: 18px;
      color: var(--muted);
      font-size: .92rem;
    }

    /* Print */
    @page{ size: A4; margin: 16mm; }
    @media print{
      :root{ --accent:#000000; }
      body{ background:#fff; }
      .page{ max-width: none; padding: 0; }
      header{ border-radius: 0; box-shadow: none; }
      .chip{ border-color:#cfcfcf; }
      a{ color: inherit; text-decoration: none; }
      pre{ page-break-inside: avoid; }
      .box, .callout, table, .diagram{ page-break-inside: avoid; }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <h1>ğŸ§  React Reviewer: Managing State with <span class="inline">useReducer</span></h1>
      <p class="subtitle">Beginner-friendly notes + examples from your lecture transcript (reducers, actions, dispatch, diagrams, and an analogy).</p>
      <div class="meta">
        <span class="chip">ğŸ§© Topic: Advanced state updates</span>
        <span class="chip">ğŸ§¾ Focus: Reducer mechanics</span>
        <span class="chip">âœ… Goal: Cleaner components</span>
      </div>
    </header>

    <main>
      <div class="callout ok">
        <p class="kicker">ğŸ¯ Main idea</p>
        <p>
          <span class="inline">useReducer</span> centralizes all state-update logic in one place: the <strong>reducer function</strong>.
          This is especially useful when state is <strong>complex</strong>, <strong>related</strong>, or updated in <strong>many places</strong>.
        </p>
      </div>

      <h2>ğŸ˜µ Why <span class="inline">useState</span> can get messy</h2>
      <div class="box">
        <p>As apps grow, <span class="inline">useState</span> can become hard to manage when:</p>
        <ul>
          <li>ğŸ§± A component has <strong>many state variables</strong>.</li>
          <li>ğŸ§µ State updates are <strong>spread across many event handlers</strong> (or even multiple components).</li>
          <li>ğŸ§¯ One user event needs <strong>multiple state updates at once</strong> (example: start a game â†’ reset score, set â€œisPlayingâ€, start timer).</li>
          <li>ğŸ”— Updating one state depends on <strong>other state values</strong> (dependencies and coordination).</li>
        </ul>
        <p><strong>Result:</strong> logic becomes scattered, repetitive, and difficult to reason about.</p>
      </div>

      <h2>ğŸ§© What <span class="inline">useReducer</span> is</h2>
      <div class="box">
        <p>
          <span class="inline">useReducer</span> is an <strong>alternative way</strong> to manage state. Itâ€™s ideal for:
        </p>
        <ul>
          <li>ğŸ§  Complex state</li>
          <li>ğŸ§· Related pieces of state</li>
          <li>ğŸ§­ Many possible state transitions</li>
        </ul>
        <p>
          Typical usage (returns <strong>state</strong> and <strong>dispatch</strong>):
        </p>
        <pre><code>const [state, dispatch] = useReducer(reducer, initialState);
// state: current state snapshot
// dispatch(action): triggers an update via the reducer</code></pre>
      </div>

      <h2>ğŸ§± The 4 core pieces (memorize this)</h2>
      <div class="grid">
        <div class="box">
          <h3>1) ğŸ¦ State</h3>
          <p>The data you want React to remember. With reducers, itâ€™s often an <strong>object</strong> (but can be primitive).</p>
          <pre><code>const initialState = { count: 0, step: 1 };</code></pre>
        </div>

        <div class="box">
          <h3>2) ğŸ§® Reducer function</h3>
          <p>
            A <strong>pure</strong> function that receives <span class="inline">(state, action)</span> and returns the <strong>next state</strong>.
          </p>
          <div class="callout warn">
            <p class="kicker">âš ï¸ Reducer rules</p>
            <ul>
              <li>âŒ No state mutation</li>
              <li>âŒ No side effects (no fetch, no timers, no localStorage writes)</li>
              <li>âœ… Always return a new state value/object</li>
            </ul>
          </div>
        </div>

        <div class="box">
          <h3>3) ğŸ“¨ Action object</h3>
          <p>
            An object describing <em>what happened</em> and optionally carrying data.
            Most common convention:
          </p>
          <pre><code>{ type: "setCount", payload: 23 }
// type: what to do
// payload: input data (optional)</code></pre>
        </div>

        <div class="box">
          <h3>4) ğŸ•¹ï¸ Dispatch function</h3>
          <p>
            You call <span class="inline">dispatch(action)</span> inside event handlers/effects.
            It sends the action to the reducer.
          </p>
          <pre><code>dispatch({ type: "inc" });
dispatch({ type: "setCount", payload: 10 });</code></pre>
        </div>
      </div>

      <h2>ğŸ§­ How state updates flow (diagram)</h2>
      <div class="diagram">
        <pre><code>Event handler
   â”‚
   â”‚  dispatch({ type, payload })  ğŸ“¨
   â–¼
Reducer(state, action)  ğŸ§®  (pure)
   â”‚
   â”‚  return nextState
   â–¼
React updates state ğŸ¦
   â”‚
   â–¼
Component re-renders ğŸ–¥ï¸</code></pre>
      </div>

      <h2>ğŸ†š useState vs useReducer (mechanism comparison)</h2>
      <table>
        <thead>
          <tr>
            <th>Hook</th>
            <th>What you call to update</th>
            <th>What you pass</th>
            <th>Where update logic lives</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>useState</strong></td>
            <td><span class="inline">setState</span></td>
            <td>New value (or updater function)</td>
            <td>Often spread across handlers</td>
          </tr>
          <tr>
            <td><strong>useReducer</strong></td>
            <td><span class="inline">dispatch</span></td>
            <td>Action object (type + optional payload)</td>
            <td><strong>Centralized in reducer</strong></td>
          </tr>
        </tbody>
      </table>

      <div class="callout ok">
        <p class="kicker">âœ… Why reducers feel â€œcleanâ€</p>
        <p>
          Event handlers become small: they mainly <strong>dispatch</strong>.
          The reducer contains the â€œbusiness rulesâ€ of how state changes.
        </p>
      </div>

      <h2>ğŸ§  Why itâ€™s called a â€œreducerâ€</h2>
      <div class="box">
        <p>
          It matches the idea of JavaScriptâ€™s array <span class="inline">reduce()</span>:
          many inputs get â€œaccumulatedâ€ into one output.
        </p>
        <ul>
          <li>Array reduce: values â†’ one accumulated value</li>
          <li>React reducer: actions over time â†’ one accumulated state</li>
        </ul>
      </div>

      <h2>ğŸ¦ The bank analogy (super useful)</h2>
      <div class="box">
        <p>
          You want to withdraw <strong>$5,000</strong>. You donâ€™t go into the vault yourself.
          You tell a bank worker what you want, and they perform the update.
        </p>
        <table>
          <thead>
            <tr>
              <th>Bank story</th>
              <th>useReducer piece</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>ğŸ¦ Vault (where money is stored)</td>
              <td><strong>State</strong> (where data lives)</td>
            </tr>
            <tr>
              <td>ğŸ™‹ Customer requesting money</td>
              <td><strong>Dispatcher</strong> (the code that triggers updates)</td>
            </tr>
            <tr>
              <td>ğŸ§‘â€ğŸ’¼ Bank worker who knows the rules</td>
              <td><strong>Reducer</strong> (central logic that performs updates)</td>
            </tr>
            <tr>
              <td>ğŸ§¾ Request message (withdraw + details)</td>
              <td><strong>Action</strong> (type + payload)</td>
            </tr>
          </tbody>
        </table>
        <p>
          <strong>Key insight:</strong> you donâ€™t mutate the vault directly.
          You send an instruction (action) and a specialist (reducer) performs it.
        </p>
      </div>

      <h2>ğŸ§ª Example: a small reducer (beginner-friendly)</h2>
      <div class="box">
        <p>Below is a reducer pattern that matches your â€œcount + stepâ€ demo:</p>
        <pre><code>const initialState = { count: 0, step: 1 };

function reducer(state, action) {
  switch (action.type) {
    case "inc":
      return { ...state, count: state.count + state.step };

    case "dec":
      return { ...state, count: state.count - state.step };

    case "setCount":
      return { ...state, count: action.payload };

    case "setStep":
      return { ...state, step: action.payload };

    case "reset":
      return initialState;

    default:
      throw new Error("Unknown action: " + action.type);
  }
}

// usage
const [state, dispatch] = useReducer(reducer, initialState);
const { count, step } = state;</code></pre>

        <p>
          Notice how the reducer returns a <strong>new object</strong> each time using
          <span class="inline">{ ...state, changedProp: newValue }</span>.
        </p>
      </div>

      <h2>ğŸ§° How your event handlers look with dispatch</h2>
      <div class="box">
        <p>
          With reducers, handlers often become â€œone-linersâ€:
        </p>
        <pre><code>// Buttons
onClick={() =&gt; dispatch({ type: "dec" })}
onClick={() =&gt; dispatch({ type: "inc" })}
onClick={() =&gt; dispatch({ type: "reset" })}

// Inputs
onChange={(e) =&gt; dispatch({ type: "setCount", payload: Number(e.target.value) })}
onChange={(e) =&gt; dispatch({ type: "setStep", payload: Number(e.target.value) })}</code></pre>
      </div>

      <h2>ğŸ§  When useReducer is a good choice</h2>
      <div class="box">
        <ul>
          <li>ğŸ§± State has multiple related values (object/arrays) and many transitions.</li>
          <li>ğŸ” Multiple state updates must happen together under one â€œeventâ€.</li>
          <li>ğŸ§© You want a single â€œsource of truthâ€ for update rules (the reducer).</li>
          <li>ğŸ§ª You want update logic thatâ€™s easy to test (pure function).</li>
        </ul>
      </div>

      <h2>âš ï¸ Common beginner mistakes</h2>
      <div class="callout bad">
        <p class="kicker">ğŸš« Avoid these</p>
        <ul>
          <li>Mutating state inside the reducer (e.g., <span class="inline">state.count++</span>).</li>
          <li>Doing side effects in reducer (fetch/localStorage/timers).</li>
          <li>Returning the wrong shape (e.g., reducer returns number but state is object).</li>
          <li>Using inconsistent action types (typos like <span class="inline">"inc"</span> vs <span class="inline">"Inc"</span>).</li>
        </ul>
      </div>

      <h2>ğŸ§¾ Quick cheat sheet (1-slide summary)</h2>
      <div class="box">
        <ul>
          <li>ğŸ§  <strong>Reducer</strong> = pure function: <span class="inline">(state, action) =&gt; nextState</span></li>
          <li>ğŸ“¨ <strong>Action</strong> = instruction object: <span class="inline">{ type, payload? }</span></li>
          <li>ğŸ•¹ï¸ <strong>Dispatch</strong> = send action: <span class="inline">dispatch(action)</span></li>
          <li>ğŸ¦ <strong>State</strong> = stored data (often object for related values)</li>
          <li>ğŸ” Reducer returns next state â†’ React re-renders</li>
        </ul>
      </div>

      <div class="hr"></div>

      <p class="footer">
        Print tip: Use your browserâ€™s Print dialog and select A4. This page is designed to avoid cut-off text and to keep boxes/code blocks together when printing.
      </p>
    </main>
  </div>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Updating User Data & Password (Supabase + React Query) ‚Äî Study Guide</title>
  <style>
    :root{
      --bg:#ffffff;
      --text:#111111;
      --muted:#555555;
      --border:#e6e6e6;
      --soft:#fafafa;
      --codebg: #f5f5f5;   /* light gray */
      --codefg: #111111; /* optional: make text dark */
      --accent:#0b57d0;
      --ok:#0a7a3d;
      --warn:#a15c00;
      --bad:#b42318;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height:1.6;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* Single-column print-friendly layout */
    .page{
      max-width: 900px;
      margin: 0 auto;
      padding: 28px 22px;
    }

    header{
      border:1px solid var(--border);
      background:var(--soft);
      padding:18px 18px;
      border-radius:12px;
      margin-bottom:16px;
    }

    h1{
      margin:0 0 6px 0;
      font-size: 24px;
      letter-spacing: .2px;
    }
    .subtitle{color:var(--muted); margin:0; font-size:14px;}

    h2{
      margin:18px 0 10px;
      font-size: 18px;
      border-left: 4px solid var(--accent);
      padding-left:10px;
    }

    h3{margin:14px 0 8px; font-size:16px;}
    p{margin:10px 0;}

    .card{
      border:1px solid var(--border);
      border-radius:12px;
      padding:14px 14px;
      background:#fff;
      margin:12px 0;
      break-inside: avoid;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }

    .kpi{
      border:1px dashed var(--border);
      border-radius:10px;
      padding:10px 12px;
      background: #fff;
    }

    .tag{
      display:inline-block;
      border:1px solid var(--border);
      background:#fff;
      border-radius:999px;
      padding:4px 10px;
      font-size:12px;
      color:var(--muted);
      margin: 4px 6px 0 0;
    }

    .callout{
      border:1px solid var(--border);
      border-left: 6px solid var(--accent);
      border-radius:10px;
      padding:12px 12px;
      background: #fff;
      margin:12px 0;
      break-inside: avoid;
    }
    .callout.ok{border-left-color: var(--ok)}
    .callout.warn{border-left-color: var(--warn)}
    .callout.bad{border-left-color: var(--bad)}
    .callout .title{font-weight:700; margin-bottom:6px;}

    ul{margin:8px 0 8px 20px; padding:0;}
    li{margin:6px 0;}

    pre{
      background: var(--codebg);
      color: var(--codefg);
      padding: 12px 12px;
      border-radius: 12px;
      overflow:auto;
      margin:10px 0;
      border:1px solid rgba(255,255,255,.08);
      break-inside: avoid;
    }

    code{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12.5px;}

    .muted{color:var(--muted)}
    .small{font-size: 12.5px; color: var(--muted)}

    .divider{height:1px; background:var(--border); margin:14px 0;}

    /* Print rules */
    @page { size: A4; margin: 14mm; }
    @media print {
      body{ background:#fff; }
      .page{ max-width:none; padding:0; }
      header{ background:#fff; }
      a{ color: inherit; text-decoration:none; }
      pre{ white-space: pre-wrap; word-wrap: break-word; }
      .card,.callout,header{ break-inside: avoid; page-break-inside: avoid; }
    }
  </style>
</head>
<body>
  <main class="page">
    <header>
      <h1>Updating User Data & Password (Supabase + React Query)</h1>
      <p class="subtitle">Reviewer / Study Guide ‚Äî Update full name, password, and avatar upload + common caching pitfalls</p>
      <div>
        <span class="tag">üß© React</span>
        <span class="tag">‚ö° React Query</span>
        <span class="tag">üóÑÔ∏è Supabase Auth</span>
        <span class="tag">üß∫ Supabase Storage</span>
        <span class="tag">üß™ Debugging</span>
      </div>
    </header>

    <section class="card">
      <h2>What you‚Äôre building (high level) üèóÔ∏è</h2>
      <div class="grid">
        <div class="kpi">
          <div><strong>Feature:</strong> Users can update account details</div>
          <ul>
            <li>‚úÖ Update <strong>Full Name</strong></li>
            <li>‚úÖ Update <strong>Password</strong></li>
            <li>‚úÖ Upload <strong>Avatar</strong> image</li>
          </ul>
        </div>
        <div class="kpi">
          <div><strong>Key idea:</strong> One service function handles both forms</div>
          <ul>
            <li>üîÅ Form A: updates name (and optional avatar)</li>
            <li>üîÅ Form B: updates password</li>
            <li>‚ö†Ô∏è You generally update <strong>either</strong> password <strong>or</strong> metadata, not both at once</li>
          </ul>
        </div>
      </div>
    </section>

    <section class="callout ok">
      <div class="title">‚úÖ Core workflow</div>
      <ol>
        <li><strong>Update auth user</strong> via <code>supabase.auth.updateUser()</code> (password or metadata)</li>
        <li><strong>If avatar selected:</strong> upload file to <code>supabase.storage.from('avatars').upload()</code></li>
        <li><strong>Update auth user again</strong> with the avatar URL saved in user metadata</li>
      </ol>
    </section>

    <section class="card">
      <h2>Important concepts (beginner-friendly) üîë</h2>

      <h3>1) Supabase Auth ‚Äúuser metadata‚Äù</h3>
      <p>
        Supabase has a built-in Auth system. Your ‚Äúusers‚Äù aren‚Äôt in a normal table you query with SQL.
        Instead, user profile info like <strong>fullName</strong> and <strong>avatar</strong> typically lives in
        <strong>user metadata</strong>.
      </p>
      <pre><code>// When signing up (or updating), metadata goes inside `data`
{
  data: {
    fullName: "Jonas",
    avatar: ""
  }
}
</code></pre>

      <h3>2) React Query + mutations</h3>
      <p>
        Updates like ‚Äúchange password‚Äù or ‚Äúupdate profile‚Äù are <strong>mutations</strong> because they change server state.
        After a successful mutation, you typically <strong>invalidate</strong> the cached user query so UI refreshes.
      </p>

      <h3>3) Storage bucket policies (very important) üîí</h3>
      <p>
        Uploading avatars requires your storage bucket to allow authenticated users.
        If policies aren‚Äôt correct, uploads fail even if your code is correct.
      </p>
    </section>

    <section class="card">
      <h2>Step-by-step implementation (what to code) üß≠</h2>

      <h3>A) Account page uses two prebuilt forms</h3>
      <ul>
        <li>üßæ <strong>UpdateUserDataForm</strong> ‚Äî email (disabled), full name, file input</li>
        <li>üîê <strong>UpdatePasswordForm</strong> ‚Äî password + confirm password (React Hook Form validation)</li>
      </ul>

      <h3>B) Service: <code>updateCurrentUser()</code> in <code>apiAuth.js</code></h3>
      <p class="muted">
        This service function updates password or metadata first. If an avatar file exists, upload it to storage,
        then update the user again with the avatar URL.
      </p>

      <pre><code>// apiAuth.js
import supabase, { supabaseUrl } from "./supabase";

export async function updateCurrentUser({ password, fullName, avatar }) {
  // 1) Prepare payload for updateUser()
  let updateData;

  if (password) updateData = { password };
  if (fullName) updateData = { data: { fullName } };

  // 2) Update password OR name
  const { data, error } = await supabase.auth.updateUser(updateData);
  if (error) throw new Error(error.message);

  // 3) If no avatar, we are done
  if (!avatar) return data;

  // 4) Upload avatar to Storage
  const fileName = `avatar-${data.user.id}-${Math.random()}`;

  const { error: storageError } = await supabase.storage
    .from("avatars")
    .upload(fileName, avatar);

  if (storageError) throw new Error(storageError.message);

  // 5) Update user with avatar URL
  const { data: updatedUser, error: error2 } = await supabase.auth.updateUser({
    data: {
      avatar: `${supabaseUrl}/storage/v1/object/public/avatars/${fileName}`,
    },
  });

  if (error2) throw new Error(error2.message);

  return updatedUser;
}
</code></pre>

      <div class="callout warn">
        <div class="title">‚ö†Ô∏è Note about <code>supabaseUrl</code></div>
        <p>
          Store your Supabase URL in one place (e.g., <code>supabaseUrl</code> export) so your avatar link is consistent.
          This mirrors how you handled cabin image URLs earlier.
        </p>
      </div>

      <h3>C) React Query hook: <code>useUpdateUser()</code></h3>
      <pre><code>// useUpdateUser.js
import { useMutation, useQueryClient } from "@tanstack/react-query";
import toast from "react-hot-toast";
import { updateCurrentUser } from "../../services/apiAuth";

export function useUpdateUser() {
  const queryClient = useQueryClient();

  const { mutate: updateUser, isLoading: isUpdating } = useMutation({
    mutationFn: updateCurrentUser,
    onSuccess: () =&gt; {
      toast.success("User account successfully updated");
      // simplest approach: force a refetch of user
      queryClient.invalidateQueries({ queryKey: ["user"] });
    },
    onError: (err) =&gt; toast.error(err.message),
  });

  return { updateUser, isUpdating };
}
</code></pre>

      <h3>D) UpdateUserDataForm (controlled inputs + cancel/reset)</h3>
      <p>
        You keep <strong>fullName</strong> and <strong>avatar</strong> in component state. Email is read-only/disabled.
      </p>
      <pre><code>// UpdateUserDataForm.jsx (simplified)
import { useState } from "react";
import { useUser } from "./useUser";
import { useUpdateUser } from "./useUpdateUser";

export default function UpdateUserDataForm() {
  const { user } = useUser();
  const { updateUser, isUpdating } = useUpdateUser();

  const email = user.email;
  const currentName = user.user_metadata?.fullName ?? "";

  const [fullName, setFullName] = useState(currentName);
  const [avatar, setAvatar] = useState(null);

  function handleSubmit(e) {
    e.preventDefault();
    if (!fullName) return;

    updateUser(
      { fullName, avatar },
      {
        onSettled: () =&gt; {
          setAvatar(null);
          e.target.reset(); // clears file input (HTML reset)
        },
      }
    );
  }

  function handleCancel() {
    setFullName(currentName);
    setAvatar(null);
  }

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label&gt;Email&lt;/label&gt;
      &lt;input value={email} disabled /&gt;

      &lt;label&gt;Full name&lt;/label&gt;
      &lt;input
        value={fullName}
        onChange={(e) =&gt; setFullName(e.target.value)}
        disabled={isUpdating}
      /&gt;

      &lt;label&gt;Avatar&lt;/label&gt;
      &lt;input
        type="file"
        accept="image/*"
        onChange={(e) =&gt; setAvatar(e.target.files?.[0] ?? null)}
        disabled={isUpdating}
      /&gt;

      &lt;button disabled={isUpdating}&gt;Update account&lt;/button&gt;
      &lt;button type="reset" onClick={handleCancel} disabled={isUpdating}&gt;
        Cancel
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>

      <div class="callout">
        <div class="title">üìù Why <code>e.target.reset()</code>?</div>
        <p>
          File inputs are tricky. Resetting the form clears the file input UI.
          You also manually clear the avatar state with <code>setAvatar(null)</code>.
        </p>
      </div>

      <h3>E) UpdatePasswordForm (React Hook Form validation)</h3>
      <p>
        Use React Hook Form so you can easily:
      </p>
      <ul>
        <li>‚úÖ enforce minimum length (e.g., 8 characters)</li>
        <li>‚úÖ confirm password matches</li>
        <li>‚úÖ reset inputs AND errors with <code>reset()</code></li>
      </ul>

      <pre><code>// UpdatePasswordForm.jsx (simplified)
import { useForm } from "react-hook-form";
import { useUpdateUser } from "./useUpdateUser";

export default function UpdatePasswordForm() {
  const { updateUser, isUpdating } = useUpdateUser();
  const { register, handleSubmit, getValues, reset, formState: { errors } } = useForm();

  function onSubmit({ password }) {
    updateUser(
      { password },
      { onSettled: () =&gt; reset() }
    );
  }

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;label&gt;New password&lt;/label&gt;
      &lt;input
        type="password"
        disabled={isUpdating}
        {...register("password", {
          required: "This field is required",
          minLength: { value: 8, message: "Min length is 8" },
        })}
      /&gt;
      {errors.password?.message &amp;&amp; &lt;p&gt;{errors.password.message}&lt;/p&gt;}

      &lt;label&gt;Confirm password&lt;/label&gt;
      &lt;input
        type="password"
        disabled={isUpdating}
        {...register("passwordConfirm", {
          required: "This field is required",
          validate: (value) =&gt; value === getValues().password || "Passwords need to match",
        })}
      /&gt;
      {errors.passwordConfirm?.message &amp;&amp; &lt;p&gt;{errors.passwordConfirm.message}&lt;/p&gt;}

      &lt;button disabled={isUpdating}&gt;Update password&lt;/button&gt;
      &lt;button type="button" onClick={() =&gt; reset()} disabled={isUpdating}&gt;
        Cancel
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>

      <div class="callout warn">
        <div class="title">‚ö†Ô∏è Why not HTML <code>type="reset"</code> here?</div>
        <p>
          HTML reset clears inputs but may not clear <strong>React Hook Form</strong> errors.
          Using RHF‚Äôs <code>reset()</code> clears values and errors together.
        </p>
      </div>

    </section>

    <section class="card">
      <h2>Supabase Storage policy reminder üîê</h2>
      <p>
        Your <strong>avatars</strong> bucket must have policies that allow authenticated users to upload.
        A typical approach is to allow:
      </p>
      <ul>
        <li>üì• <strong>INSERT</strong> (upload) for authenticated users</li>
        <li>üì§ <strong>SELECT</strong> for public read if you use a <code>public</code> bucket (or restrict as needed)</li>
      </ul>
      <div class="callout bad">
        <div class="title">üö® Security note</div>
        <p>
          Leaving storage policies open to everyone can expose user files.
          For production, restrict access appropriately and consider private buckets + signed URLs.
        </p>
      </div>
    </section>

    <section class="card">
      <h2>Common bug: avatar not updating immediately üêõ</h2>
      <p>
        You may upload a new avatar successfully, but the header still shows the old image until a refresh.
        This usually happens because the cached <code>user</code> query wasn‚Äôt updated/refetched yet.
      </p>

      <h3>Fix options</h3>
      <ul>
        <li>‚úÖ <strong>Simple</strong>: <code>invalidateQueries(['user'])</code> after success (recommended first)</li>
        <li>‚ö° <strong>Advanced</strong>: manually update cache via <code>queryClient.setQueryData</code></li>
      </ul>

      <pre><code>// Advanced cache update example
onSuccess: (data) =&gt; {
  // data looks like: { user, ... }
  queryClient.setQueryData(["user"], data.user);
}
</code></pre>

      <div class="callout warn">
        <div class="title">‚ö†Ô∏è Be careful with the returned shape</div>
        <p>
          Supabase often returns <code>{ user, session }</code> (or an object containing user).
          Your <code>useUser</code> query may store only the <code>user</code> object.
          If you set the wrong shape into cache, other code may break.
        </p>
      </div>
    </section>

    <section class="card">
      <h2>Quick checklist ‚úÖ</h2>
      <ul>
        <li>‚úÖ <code>updateCurrentUser()</code> handles: password OR fullName first</li>
        <li>‚úÖ If avatar provided: upload to <code>avatars</code> bucket, then update metadata with URL</li>
        <li>‚úÖ Storage bucket policies allow authenticated upload</li>
        <li>‚úÖ React Query invalidates <code>["user"]</code> after update</li>
        <li>‚úÖ Forms disable inputs while updating (prevents double-submit)</li>
        <li>‚úÖ Password form uses React Hook Form for confirm match validation</li>
      </ul>
    </section>

    <section class="callout ok">
      <div class="title">üéØ Outcome</div>
      <p>
        After this feature, your app‚Äôs authentication isn‚Äôt just login/logout ‚Äî it now supports real-world
        account management: profile updates, password changes, and user avatars.
      </p>
      <p class="small">Next topic in the course: Dark Mode üåô</p>
    </section>

  </main>
</body>
</html>

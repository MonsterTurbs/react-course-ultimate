

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>React Context API ‚Äî Advanced Pattern: Custom Provider + Custom Hook (Study Guide)</title>
  <style>
    :root {
      --bg: #ffffff;
      --text: #111111;
      --muted: #555555;
      --border: #e6e6e6;
      --soft: #fafafa;
      --codebg: #f5f5f5;   /* light gray */
      --codefg: #111111; /* optional: make text dark */
      --accent: #1a73e8;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.6;
      overflow-wrap: anywhere;
      word-break: break-word;
    }

    /* Single-column page container */
    .page {
      max-width: 900px;
      margin: 0 auto;
      padding: 28px 18px 64px;
    }

    header {
      border-bottom: 1px solid var(--border);
      padding-bottom: 14px;
      margin-bottom: 18px;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 1.75rem;
      letter-spacing: -0.2px;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 1rem;
    }

    .meta {
      margin-top: 10px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      background: var(--soft);
      border-radius: 10px;
      color: var(--muted);
      font-size: 0.95rem;
    }

    h2 {
      margin: 22px 0 10px;
      font-size: 1.25rem;
      border-left: 4px solid var(--accent);
      padding-left: 10px;
    }

    h3 {
      margin: 16px 0 8px;
      font-size: 1.05rem;
    }

    p { margin: 10px 0; }

    ul, ol {
      margin: 8px 0 12px 22px;
      padding: 0;
    }

    li { margin: 6px 0; }

    .callout {
      border: 1px solid var(--border);
      background: #ffffff;
      border-radius: 12px;
      padding: 12px 14px;
      margin: 12px 0;
    }

    .callout.soft { background: var(--soft); }
    .callout strong { color: #0f172a; }

    .kvs {
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      margin: 10px 0 14px;
    }

    .kvs .row {
      display: grid;
      grid-template-columns: 220px 1fr;
      gap: 12px;
      padding: 10px 12px;
      border-top: 1px solid var(--border);
    }

    .kvs .row:first-child { border-top: 0; }
    .kvs .key { color: var(--muted); font-weight: 700; }

    code.inline {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 0.95em;
      background: #f3f4f6;
      border: 1px solid var(--border);
      padding: 0 6px;
      border-radius: 6px;
      white-space: nowrap;
    }

    pre {
      margin: 10px 0 14px;
      padding: 12px 14px;
      background: var(--codebg);
      color: var(--codefg);
      border-radius: 12px;
      overflow: auto;
      border: 1px solid #111827;
    }

    pre code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 0.92rem;
      white-space: pre;
    }

    .divider {
      border: 0;
      border-top: 1px dashed var(--border);
      margin: 18px 0;
    }

    .toc {
      border: 1px solid var(--border);
      background: var(--soft);
      border-radius: 12px;
      padding: 12px 14px;
      margin: 14px 0 18px;
    }

    .toc a {
      color: var(--text);
      text-decoration: none;
    }

    .toc a:hover { text-decoration: underline; }

    .tag {
      display: inline-block;
      border: 1px solid var(--border);
      background: #ffffff;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.85rem;
      color: var(--muted);
      margin-right: 6px;
    }

    /* Print settings */
    @page { size: A4; margin: 14mm; }

    @media print {
      body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
      .page { max-width: none; padding: 0; }
      a { color: inherit; text-decoration: none; }
      a[href]::after { content: ""; } /* Do not print URLs */
      pre { page-break-inside: avoid; }
      h2, h3 { page-break-after: avoid; }
      .callout, .kvs, .toc { page-break-inside: avoid; }
    }
  </style>
</head>
<body>
  <main class="page">
    <header>
      <h1>üß© Advanced Context Pattern: Custom Provider + Custom Hook</h1>
      <p class="subtitle">Refactor your Context API setup so your <strong>App component stays clean</strong> and your context becomes easy and safe to consume.</p>
      <div class="meta">
        <span class="tag">React</span>
        <span class="tag">Context API</span>
        <span class="tag">Provider Pattern</span>
        <span class="tag">Custom Hook</span>
        <div style="margin-top:8px;">
          Goal: move state + logic into a dedicated <code class="inline">PostProvider</code>, and consume via <code class="inline">usePosts()</code>.
        </div>
      </div>
    </header>

    <section class="toc" aria-label="Table of contents">
      <strong>üìå Table of Contents</strong>
      <ol>
        <li><a href="#why">Why refactor if it already works?</a></li>
        <li><a href="#provider">Part 1: Build a custom Provider component</a></li>
        <li><a href="#children">Key idea: the <code class="inline">children</code> prop</a></li>
        <li><a href="#hook">Part 2: Build a custom hook (<code class="inline">usePosts</code>)</a></li>
        <li><a href="#guard">Prevent bugs: throw if used outside the Provider</a></li>
        <li><a href="#recipe">Copy-paste recipe you can reuse</a></li>
        <li><a href="#checklist">Checklist + quick review questions</a></li>
      </ol>
    </section>

    <section id="why">
      <h2>‚úÖ Why refactor if the current Context works?</h2>
      <p>Your current implementation (creating context in <code class="inline">App</code>, wrapping <code class="inline">PostContext.Provider</code>, and consuming with <code class="inline">useContext(PostContext)</code>) is valid and common.</p>

      <div class="callout soft">
        <strong>Why improve it anyway?</strong>
        <ul>
          <li>üßπ <strong>Cleaner App component:</strong> App focuses on layout, not state plumbing.</li>
          <li>üì¶ <strong>Encapsulation:</strong> all context logic lives in one file (easy to maintain).</li>
          <li>üîÅ <strong>Less repetition:</strong> no more repeating <code class="inline">useContext(PostContext)</code> everywhere.</li>
          <li>üõ°Ô∏è <strong>Safety:</strong> you can prevent ‚Äúused outside Provider‚Äù bugs with a clear error.</li>
        </ul>
      </div>

      <div class="kvs" role="group" aria-label="Before vs After">
        <div class="row">
          <div class="key">Before</div>
          <div>Context creation + state + handlers inside <code class="inline">App</code>.</div>
        </div>
        <div class="row">
          <div class="key">After</div>
          <div>Dedicated <code class="inline">PostProvider</code> component + <code class="inline">usePosts()</code> hook.</div>
        </div>
      </div>
    </section>

    <hr class="divider" />

    <section id="provider">
      <h2>üèóÔ∏è Part 1: Build a custom Provider component</h2>
      <p>The goal is to move <strong>all context-related code</strong> into a separate file (example: <code class="inline">PostContext.js</code>), and export a component called <code class="inline">PostProvider</code>.</p>

      <h3>Step-by-step (high-level)</h3>
      <ol>
        <li>üß† Create the context: <code class="inline">createContext()</code></li>
        <li>üì¶ Create a Provider component: <code class="inline">function PostProvider({ children })</code></li>
        <li>üßæ Move state + logic into that Provider component</li>
        <li>üì° Provide a value object via <code class="inline">PostContext.Provider</code></li>
        <li>üë∂ Render the <code class="inline">children</code> inside the Provider</li>
      </ol>

      <div class="callout">
        <strong>Important naming tip</strong>
        <p>
          Your context object might be called <code class="inline">PostContext</code>, but your component should be called <code class="inline">PostProvider</code>.
          This makes the intent obvious: it <em>provides</em> context.
        </p>
      </div>

      <h3>Example: <code class="inline">PostContext.js</code></h3>
      <pre><code>import { createContext, useState } from "react";

// 1) Create context (usually with no default value)
const PostContext = createContext();

function PostProvider({ children }) {
  // 2) Move state + logic here (posts, search, handlers, etc.)
  const [posts, setPosts] = useState([]);
  const [searchQuery, setSearchQuery] = useState("");

  function handleAddPost(newPost) {
    setPosts((posts) =&gt; [newPost, ...posts]);
  }

  function handleClearPosts() {
    setPosts([]);
  }

  // 3) Provide the value (what consumers will read)
  const value = {
    posts,
    searchQuery,
    setSearchQuery,
    onAddPost: handleAddPost,
    onClearPosts: handleClearPosts,
  };

  // 4) Wrap children inside Provider
  return (
    &lt;PostContext.Provider value={value}&gt;
      {children}
    &lt;/PostContext.Provider&gt;
  );
}

export { PostContext, PostProvider };</code></pre>

      <p>Then in your <code class="inline">App</code>, you wrap the UI that needs the context:</p>
      <pre><code>import { PostProvider } from "./PostContext";

export default function App() {
  return (
    &lt;PostProvider&gt;
      {/* components that need posts/search go here */}
      &lt;Header /&gt;
      &lt;Main /&gt;
      &lt;Footer /&gt;
    &lt;/PostProvider&gt;
  );
}</code></pre>

      <div class="callout soft">
        <strong>üß† Mental model</strong>
        <p>
          The Provider is a ‚Äúdata station.‚Äù Components <em>below it</em> can read the broadcasted value.
          Components <em>above it</em> cannot.
        </p>
      </div>
    </section>

    <section id="children">
      <h2>üë∂ Key idea: the <code class="inline">children</code> prop</h2>
      <p>
        When you write:
        <code class="inline">&lt;PostProvider&gt;...&lt;/PostProvider&gt;</code>
        everything inside becomes <code class="inline">children</code>.
      </p>

      <div class="callout">
        <strong>Common bug</strong>
        <p>
          If your Provider component returns the Provider element but forgets to render <code class="inline">{children}</code>, your app will appear empty.
        </p>
      </div>

      <pre><code>// ‚ùå WRONG (children is ignored)
return &lt;PostContext.Provider value={value} /&gt;;

// ‚úÖ RIGHT (children are rendered)
return (
  &lt;PostContext.Provider value={value}&gt;
    {children}
  &lt;/PostContext.Provider&gt;
);</code></pre>
    </section>

    <hr class="divider" />

    <section id="hook">
      <h2>ü™ù Part 2: Build a custom hook: <code class="inline">usePosts()</code></h2>
      <p>
        Consuming context typically looks like this:
        <code class="inline">useContext(PostContext)</code>.
        Over time, repeating that everywhere gets annoying.
      </p>

      <div class="callout soft">
        <strong>‚úÖ Goal</strong>
        <p>
          Hide the context object and expose a clean API:
          <code class="inline">const { posts } = usePosts()</code>
        </p>
      </div>

      <h3>Example implementation</h3>
      <pre><code>import { createContext, useContext, useState } from "react";

const PostContext = createContext();

function PostProvider({ children }) {
  const [posts, setPosts] = useState([]);

  const value = { posts, setPosts };

  return (
    &lt;PostContext.Provider value={value}&gt;
      {children}
    &lt;/PostContext.Provider&gt;
  );
}

function usePosts() {
  const context = useContext(PostContext);
  return context;
}

export { PostProvider, usePosts };</code></pre>

      <p>Now consumer components become simpler:</p>
      <pre><code>import { usePosts } from "./PostContext";

function Results() {
  const { posts } = usePosts();
  return &lt;p&gt;Results: {posts.length}&lt;/p&gt;;
}</code></pre>

      <div class="callout">
        <strong>Why this is cleaner</strong>
        <ul>
          <li>üß† You don‚Äôt need to remember the context name in every component.</li>
          <li>üìö Your context file becomes a mini ‚Äúmodule API‚Äù.</li>
          <li>üîß You can add validations and helper logic inside the hook.</li>
        </ul>
      </div>
    </section>

    <section id="guard">
      <h2>‚ö†Ô∏è Prevent bugs: throw if used outside the Provider</h2>
      <p>
        A classic mistake is calling <code class="inline">usePosts()</code> in a component that is <strong>not wrapped</strong> by <code class="inline">PostProvider</code>.
        In that case, the context value is usually <code class="inline">undefined</code>.
      </p>

      <div class="callout soft">
        <strong>Why this matters</strong>
        <p>
          Without a guard, you may get confusing errors later like
          <code class="inline">Cannot read properties of undefined</code>
          when you destructure.
        </p>
      </div>

      <h3>Add a guard inside the custom hook</h3>
      <pre><code>function usePosts() {
  const context = useContext(PostContext);

  // ‚úÖ Defensive programming: fail fast with a helpful message
  if (context === undefined)
    throw new Error("PostContext was used outside of the PostProvider");

  return context;
}</code></pre>

      <p>
        This gives you a clear, immediate error that tells you exactly what to fix:
        wrap the component tree with <code class="inline">&lt;PostProvider&gt;</code>.
      </p>
    </section>

    <hr class="divider" />

    <section id="recipe">
      <h2>üç≥ Reusable recipe (copy this pattern to your own projects)</h2>
      <ol>
        <li>‚úÖ Create a context: <code class="inline">const XContext = createContext()</code></li>
        <li>‚úÖ Create provider: <code class="inline">function XProvider({ children })</code></li>
        <li>‚úÖ Move state + logic into the provider</li>
        <li>‚úÖ Return <code class="inline">&lt;XContext.Provider value={...}&gt;{children}&lt;/XContext.Provider&gt;</code></li>
        <li>‚úÖ Create hook: <code class="inline">function useX() { return useContext(XContext) }</code></li>
        <li>‚úÖ Add guard error in the hook</li>
        <li>‚úÖ Export <code class="inline">XProvider</code> and <code class="inline">useX</code> (optionally hide the context)</li>
      </ol>

      <div class="callout">
        <strong>üß† Design principle</strong>
        <p>
          Context is not just about removing prop drilling. It‚Äôs also about creating a stable, intentional API for a ‚Äústate domain‚Äù (posts, auth, theme, etc.).
        </p>
      </div>
    </section>

    <section id="checklist">
      <h2>üßæ Checklist + quick review questions</h2>

      <div class="callout soft">
        <strong>Checklist</strong>
        <ul>
          <li>‚úÖ My provider renders <code class="inline">{children}</code> inside the Provider.</li>
          <li>‚úÖ My value is an object that contains the state + handlers I want to share.</li>
          <li>‚úÖ I consume context using <code class="inline">usePosts()</code>, not <code class="inline">useContext(PostContext)</code> everywhere.</li>
          <li>‚úÖ My custom hook throws a clear error if used outside the provider.</li>
        </ul>
      </div>

      <h3>Quick questions (self-test)</h3>
      <ol>
        <li>üß† If your screen is blank after refactoring, what‚Äôs the first thing to check inside your Provider?</li>
        <li>üß† Why is <code class="inline">usePosts()</code> undefined when called in a component above the provider?</li>
        <li>üß† What is the benefit of throwing an error when the context is <code class="inline">undefined</code>?</li>
        <li>üß† What belongs in a context value: only state, or also handler functions?</li>
      </ol>

      <div class="callout">
        <strong>Answer key (short)</strong>
        <ul>
          <li>1) You probably forgot <code class="inline">{children}</code>.</li>
          <li>2) Providers only supply values to descendants, not ancestors.</li>
          <li>3) Fail fast with a clear message, easier debugging.</li>
          <li>4) Both: state + setters/handlers is common.</li>
        </ul>
      </div>
    </section>

    <hr class="divider" />

    <footer class="meta" aria-label="Footer">
      Tip: When you later apply this to WorldWise, you‚Äôll likely create a provider for cities, loading state, CRUD actions, and selected city‚Äîthen consume it via a custom hook across CityList, Map, City, and Form.
    </footer>
  </main>
</body>
</html>
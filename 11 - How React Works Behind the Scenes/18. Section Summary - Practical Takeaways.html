

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>React Behind the Scenes â€” Section Summary (Practical Takeaways)</title>
  <style>
    :root {
      --bg: #ffffff;
      --text: #111111;
      --muted: #555555;
      --border: #e6e6e6;
      --soft: #fafafa;
      --chip: #f3f4f6;
      --accent: #0b57d0;
      --warn: #b42318;
      --ok: #05603a;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.6;
      overflow-wrap: anywhere;
      word-break: normal;
      -webkit-print-color-adjust: exact;
      print-color-adjust: exact;
    }

    /* Single-column page */
    .page {
      max-width: 860px;
      margin: 0 auto;
      padding: 28px 18px 56px;
    }

    header {
      border: 1px solid var(--border);
      background: var(--soft);
      padding: 18px;
      border-radius: 12px;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 26px;
      line-height: 1.2;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }

    .meta {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: var(--chip);
      border: 1px solid var(--border);
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }

    .toolbar {
      margin: 14px 0 0;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 14px;
      cursor: pointer;
    }
    .btn:focus { outline: 3px solid rgba(11, 87, 208, 0.18); outline-offset: 2px; }

    nav {
      margin-top: 16px;
      padding: 14px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fff;
    }

    nav h2 {
      margin: 0 0 8px;
      font-size: 16px;
    }

    nav ul {
      margin: 0;
      padding-left: 18px;
    }

    nav a {
      color: var(--accent);
      text-decoration: none;
    }
    nav a:hover { text-decoration: underline; }

    main { margin-top: 16px; }

    section {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fff;
      padding: 16px;
      margin: 14px 0;
    }

    h2 {
      margin: 0 0 10px;
      font-size: 18px;
      line-height: 1.25;
    }

    h3 {
      margin: 14px 0 8px;
      font-size: 15px;
      line-height: 1.3;
    }

    p { margin: 8px 0; }

    ul, ol { margin: 8px 0; padding-left: 20px; }

    .callout {
      border-left: 4px solid var(--border);
      background: var(--soft);
      padding: 10px 12px;
      border-radius: 10px;
      margin: 10px 0;
    }

    .callout.warn { border-left-color: var(--warn); }
    .callout.ok { border-left-color: var(--ok); }

    .k {
      display: inline-block;
      padding: 2px 8px;
      border: 1px solid var(--border);
      background: var(--soft);
      border-radius: 999px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      white-space: nowrap;
    }

    pre {
      margin: 10px 0;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fff;
      overflow: auto;
    }

    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .mini {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: #fff;
    }

    .mini h3 { margin-top: 0; }

    .muted { color: var(--muted); }

    footer {
      margin-top: 14px;
      color: var(--muted);
      font-size: 12px;
      text-align: center;
    }

    /* Print: A4 + clean output */
    @page { size: A4; margin: 14mm; }

    @media print {
      body { background: #fff; }
      .page { max-width: none; padding: 0; }
      header, nav, section { border-color: #dcdcdc; }
      .toolbar { display: none !important; }
      a { color: inherit; text-decoration: none; }
      section, header, nav { break-inside: avoid; page-break-inside: avoid; }
      pre { break-inside: avoid; page-break-inside: avoid; }
    }
  </style>
</head>

<body>
  <div class="page">
    <header>
      <h1>ğŸ§  React Behind the Scenes â€” Practical Takeaways</h1>
      <p class="subtitle">A print-friendly reviewer based on the lecture â€œSection Summary â€” Practical Takeawaysâ€.</p>
      <div class="meta">
        <span class="chip">ğŸ“„ A4 print-ready</span>
        <span class="chip">ğŸ§© Components â€¢ Rendering â€¢ Diffing</span>
        <span class="chip">âš¡ Keys â€¢ Batching â€¢ Events</span>
        <span class="chip">âœ… Beginner-friendly</span>
      </div>

      <div class="toolbar" aria-label="Actions">
        <button class="btn" type="button" onclick="window.print()">Print / Save as PDF</button>
        <button class="btn" type="button" onclick="document.getElementById('top').scrollIntoView({behavior:'smooth'})">Back to top</button>
      </div>

      <p class="callout" style="margin-top:14px" id="top">
        ğŸ¯ Goal: keep only the <strong>practical implications</strong> you need while building real React apps.
        The internals are interesting, but you mainly need to know how they affect <strong>state, performance, and bugs</strong>.
      </p>
    </header>

    <nav aria-label="Table of contents">
      <h2>ğŸ“Œ Table of Contents</h2>
      <ul>
        <li><a href="#takeaways">Key takeaways at a glance</a></li>
        <li><a href="#components">Components vs Instances vs React Elements</a></li>
        <li><a href="#rendering">Rendering vs Committing (and what triggers renders)</a></li>
        <li><a href="#reconciliation">Reconciliation & diffing rules</a></li>
        <li><a href="#keys">Key prop: performance + resetting state</a></li>
        <li><a href="#dont-nest">Rule: never declare a component inside another component</a></li>
        <li><a href="#purity">Render logic must be pure (no side effects)</a></li>
        <li><a href="#reactdom">Commit phase uses ReactDOM (renderers)</a></li>
        <li><a href="#batching">Batching & async state updates</a></li>
        <li><a href="#events">Events: delegation + synthetic events</a></li>
        <li><a href="#library">React is a library (ecosystem & frameworks)</a></li>
      </ul>
    </nav>

    <main>
      <section id="takeaways">
        <h2>âœ… Key takeaways at a glance</h2>
        <ul>
          <li>ğŸ§© A <strong>component</strong> is a blueprint; a <strong>component instance</strong> is the real â€œlivingâ€ copy in the tree.</li>
          <li>ğŸ§  In React, <strong>rendering</strong> = calling component functions + computing what should change (not updating the DOM).</li>
          <li>ğŸ§± DOM updates happen in the <strong>commit</strong> phase (done by a renderer like <strong>ReactDOM</strong>).</li>
          <li>ğŸ” If a component instance re-renders, <strong>all children re-render</strong> (but not all DOM necessarily updates).</li>
          <li>ğŸ§® <strong>Diffing</strong> decides what DOM changes are needed. Same element in same position keeps state.</li>
          <li>ğŸ”‘ <strong>Keys</strong> help React keep list items stable and can also <strong>reset state</strong> when the key changes.</li>
          <li>âš ï¸ Never declare a component inside another component (it can reset state unexpectedly).</li>
          <li>ğŸ§¼ Render logic must be <strong>pure</strong>: no side effects, no state updates, no mutations.</li>
          <li>âš¡ State updates are <strong>batched</strong> (often into one render). Updated state is available after re-render.</li>
          <li>ğŸ–±ï¸ React uses event delegation and gives you <strong>synthetic events</strong> for consistent behavior.</li>
        </ul>
      </section>

      <section id="components">
        <h2>ğŸ§© Components vs Instances vs React Elements</h2>

        <div class="grid">
          <div class="mini">
            <h3>1) Component = blueprint</h3>
            <p>A component is just a function you write that describes a piece of UI.</p>
            <p class="muted">Think: architectural blueprint.</p>
          </div>
          <div class="mini">
            <h3>2) Component instance = actual â€œlivingâ€ copy</h3>
            <p>Each time you use a component in JSX, React creates an <strong>instance</strong>.</p>
            <ul>
              <li>Has its own <strong>props</strong>, <strong>state</strong>, <strong>effects</strong></li>
              <li>Has a lifecycle (born â†’ lives â†’ unmounts)</li>
            </ul>
          </div>
          <div class="mini">
            <h3>3) React element = the output object</h3>
            <p>When an instance renders, it returns <strong>React elements</strong> (immutable JS objects) that describe what the UI should look like.</p>
          </div>
        </div>

        <div class="callout ok">
          ğŸ  Analogy recap: <strong>component</strong> = blueprint, <strong>instances</strong> = houses built from it.
        </div>
      </section>

      <section id="rendering">
        <h2>ğŸ§  Rendering vs Committing (and what triggers renders)</h2>

        <h3>React â€œrenderingâ€ means:</h3>
        <ul>
          <li>ğŸ“ Calling component functions again</li>
          <li>ğŸ§® Computing what DOM changes would be needed</li>
          <li>ğŸš« Not touching the DOM yet</li>
        </ul>

        <h3>React â€œcommittingâ€ means:</h3>
        <ul>
          <li>ğŸ§± Actually inserting/updating/removing DOM nodes</li>
          <li>ğŸ”’ Happens synchronously (in one go) to keep UI consistent</li>
        </ul>

        <h3>What triggers a render?</h3>
        <ul>
          <li>ğŸš€ <strong>Initial render</strong> (app starts)</li>
          <li>ğŸ” <strong>State updates</strong> (re-render)</li>
        </ul>

        <div class="callout">
          ğŸ” Important: a render is triggered for the <strong>whole app tree</strong> (even if it â€œlooks likeâ€ only one component changed).
        </div>

        <div class="callout warn">
          âš ï¸ When a component instance re-renders, <strong>all its children re-render too</strong>.
          This is normal and not automatically a performance problemâ€”because reconciliation can reuse most DOM.
        </div>
      </section>

      <section id="reconciliation">
        <h2>ğŸ§® Reconciliation & diffing rules</h2>
        <p>Reconciliation is how React figures out the <strong>minimum</strong> DOM operations to apply so the UI matches the latest state.</p>

        <h3>Diffing rule #1: Different type at same position â†’ destroy + rebuild</h3>
        <ul>
          <li>If <span class="k">&lt;div&gt;</span> becomes <span class="k">&lt;header&gt;</span> at the same position, React treats it as a different tree.</li>
          <li>âœ… DOM nodes get replaced</li>
          <li>ğŸ’¥ Component state under that subtree gets reset (lost)</li>
        </ul>

        <h3>Diffing rule #2: Same type at same position â†’ keep + update props/attributes</h3>
        <ul>
          <li>If itâ€™s the same element/component in the same spot, React keeps it.</li>
          <li>âœ… State is preserved</li>
          <li>ğŸ› ï¸ Only attributes/props change</li>
        </ul>

        <div class="callout">
          ğŸ§  Why this matters: the â€œsame positionâ€ rule explains why state sometimes feels like it â€œsticksâ€ when you switch views.
        </div>
      </section>

      <section id="keys">
        <h2>ğŸ”‘ The <span class="k">key</span> prop: performance + resetting state</h2>

        <h3>Use case A: Lists (stable keys = better performance)</h3>
        <p>If you insert an item at the top of a list, items below shift positions.</p>
        <ul>
          <li>Without keys: React may destroy/recreate many DOM nodes unnecessarily.</li>
          <li>With stable keys: React can keep the same items even if their position changed.</li>
        </ul>

        <pre><code>// Good: stable unique key
{questions.map(q =&gt; (
  &lt;Question key={q.id} question={q} /&gt;
))}</code></pre>

        <h3>Use case B: Resetting state (changing key = new instance)</h3>
        <p>Sometimes you want React to treat a component as â€œbrand newâ€ when a prop changes (e.g., switching tabs or switching selected friend).</p>

        <pre><code>// Trick: change key when the "identity" changes
&lt;TabContent key={activeTabId} item={content[activeTab]} /&gt;

// Another example
&lt;FormSplitBill key={selectedFriend.id} selectedFriend={selectedFriend} /&gt;</code></pre>

        <div class="callout ok">
          âœ… Rule of thumb: if the UI conceptually becomes a <strong>different entity</strong>, consider a key to reset local state.
        </div>
      </section>

      <section id="dont-nest">
        <h2>âš ï¸ Hard rule: never declare a component inside another component</h2>
        <p>If you declare a component inside another component, it gets recreated on each parent re-render.</p>
        <p>React can interpret that nested component as a â€œnew typeâ€ each time â†’ state resets unexpectedly.</p>

        <pre><code>// âŒ Donâ€™t do this
function Parent() {
  function Child() {
    const [x, setX] = useState(0);
    return &lt;div&gt;{x}&lt;/div&gt;;
  }
  return &lt;Child /&gt;;
}

// âœ… Do this instead
function Child() {
  const [x, setX] = useState(0);
  return &lt;div&gt;{x}&lt;/div&gt;;
}
function Parent() {
  return &lt;Child /&gt;;
}</code></pre>

        <div class="callout warn">
          ğŸš¨ Remember: itâ€™s not about styleâ€”it can cause real bugs and â€œmysteriousâ€ state resets.
        </div>
      </section>

      <section id="purity">
        <h2>ğŸ§¼ Render logic must be pure (no side effects)</h2>

        <h3>Render logic = code that runs during rendering</h3>
        <ul>
          <li>Top-level component code + JSX return</li>
          <li>Any helper called during render that affects what JSX is returned</li>
        </ul>

        <h3>Event handlers = code that runs because of user action</h3>
        <ul>
          <li>Click handlers, submit handlers, input change handlers, etc.</li>
          <li>These are where â€œdoing thingsâ€ belongs</li>
        </ul>

        <h3>Render logic must NOT:</h3>
        <ul>
          <li>ğŸŒ Make HTTP requests</li>
          <li>â±ï¸ Start timers</li>
          <li>ğŸ§± Directly read/write the DOM</li>
          <li>ğŸ§¨ Mutate objects outside scope (including mutating props)</li>
          <li>ğŸ” Update state/refs during render (infinite loops)</li>
        </ul>

        <div class="callout ok">
          âœ… Where side effects are allowed: <strong>event handlers</strong> and <strong>useEffect</strong>.
        </div>
      </section>

      <section id="reactdom">
        <h2>ğŸ§± Commit phase uses ReactDOM (renderers)</h2>
        <p>React (core) computes what should change. A <strong>renderer</strong> performs the actual output work.</p>
        <ul>
          <li>ğŸŒ Web: <strong>ReactDOM</strong> commits to the browser DOM</li>
          <li>ğŸ“± Mobile: <strong>React Native</strong> commits to native UI widgets</li>
          <li>ğŸ§¾ Other hosts exist (documents, video, etc.)</li>
        </ul>

        <div class="callout">
          ğŸ§  Practical note: this is why web apps import both <span class="k">react</span> and <span class="k">react-dom</span>.
        </div>
      </section>

      <section id="batching">
        <h2>âš¡ State update batching & â€œasyncâ€ state</h2>

        <h3>Batching: multiple state updates â†’ usually one re-render</h3>
        <p>In one event handler, React groups updates together for performance.</p>

        <pre><code>function handleUndo() {
  setShowDetails(true);
  setLikes(0);
  // React batches these â†’ typically one render
}</code></pre>

        <h3>State updates are â€œasynchronousâ€ in practice</h3>
        <p>You canâ€™t read the updated value immediately after calling a setter (it becomes available after re-render).</p>

        <pre><code>setLikes(0);
console.log(likes); // logs the OLD value (stale)</code></pre>

        <h3>When updating based on previous state: use the callback form</h3>
        <pre><code>// âœ… safe
setLikes(cur =&gt; cur + 1);
setLikes(cur =&gt; cur + 1);
setLikes(cur =&gt; cur + 1); // +3 total</code></pre>

        <div class="callout">
          ğŸ§  Since React 18, automatic batching also happens in timeouts, promises, and native handlers (not just direct event handlers).
        </div>
      </section>

      <section id="events">
        <h2>ğŸ–±ï¸ Events in React: delegation + synthetic events</h2>

        <h3>Quick DOM refresher</h3>
        <ul>
          <li>ğŸ“¥ Capturing phase: event travels down to target</li>
          <li>ğŸ¯ Target: event originates on the clicked element</li>
          <li>ğŸ“¤ Bubbling phase: event travels back up to the root</li>
        </ul>

        <h3>React uses event delegation</h3>
        <p>React effectively registers handlers at the <strong>root container</strong> and routes events internally (great for performance).</p>

        <h3>Synthetic events</h3>
        <ul>
          <li>React gives a <strong>synthetic event</strong> (wrapper around native browser event)</li>
          <li>Normal methods still work: <span class="k">preventDefault()</span>, <span class="k">stopPropagation()</span></li>
          <li>Helps normalize browser differences</li>
          <li>Most synthetic events bubble (even <strong>focus</strong>, <strong>blur</strong>, <strong>change</strong>)</li>
          <li>Exception: <strong>scroll</strong> does not bubble</li>
        </ul>

        <div class="callout warn">
          âš ï¸ Bubbling follows the <strong>DOM tree</strong>, not the React component tree.
        </div>
      </section>

      <section id="library">
        <h2>ğŸ“š React is a library (not a framework)</h2>

        <p>React is primarily a <strong>view library</strong>: it helps you build UI from components.</p>

        <h3>Framework (all-in-one kit) vs Library (pick ingredients)</h3>
        <ul>
          <li>ğŸ§° Frameworks often ship routing, HTTP, conventions, tooling ("batteries included").</li>
          <li>ğŸ§© React lets you choose third-party tools (routing, data fetching, styling, forms, etc.).</li>
        </ul>

        <div class="callout">
          ğŸ£ Sushi analogy: frameworks are like an all-in-one kit; React is choosing ingredients yourself.
          Freedom is powerfulâ€”but you must choose wisely.
        </div>

        <h3>Why React ecosystems feel big</h3>
        <p>You may add libraries like routing, server-state tools, global state management, styling systems, UI kits, etc.</p>

        <h3>React frameworks exist (opinionated + full stack features)</h3>
        <p>Tools like Next.js and Remix build on React and provide conventions + advanced capabilities (SSR, SSG, routing, etc.).</p>

        <div class="callout ok">
          âœ… Practical takeaway: first master core React. Then you can evaluate libraries/frameworks based on real needs.
        </div>
      </section>

      <section>
        <h2>ğŸ“ Quick self-check (for retention)</h2>
        <ol>
          <li>What is the difference between a component, instance, and React element?</li>
          <li>In React terms, what is â€œrenderingâ€ and what is â€œcommittingâ€?</li>
          <li>Why can a child re-render even if its props didnâ€™t change?</li>
          <li>When does state get preserved vs reset during diffing?</li>
          <li>What are the two big uses of <span class="k">key</span>?</li>
          <li>Why is it dangerous to define components inside components?</li>
          <li>Where are side effects allowed (and not allowed)?</li>
          <li>Why does <span class="k">console.log(state)</span> after <span class="k">setState</span> show old values?</li>
          <li>What is a synthetic event and why does React use it?</li>
        </ol>
      </section>

      <footer>
        End of reviewer â€” You can print this page to A4 PDF using your browserâ€™s Print dialog.
      </footer>
    </main>
  </div>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>React Performance â€” Donâ€™t Optimize Prematurely (Study Guide)</title>
  <style>
    :root {
      --bg: #ffffff;
      --text: #111111;
      --muted: #555555;
      --border: #e6e6e6;
      --soft: #f7f7f7;
      --codebg: #fbfbfb;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.6;
      overflow-wrap: anywhere;
      word-break: break-word;
    }

    /* Single-column page */
    .page {
      max-width: 820px;
      margin: 0 auto;
      padding: 24px 18px;
    }

    header {
      border: 1px solid var(--border);
      background: #fff;
      padding: 16px 16px 12px;
      border-radius: 10px;
    }

    h1 {
      margin: 0 0 6px;
      font-size: 22px;
      letter-spacing: 0.2px;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 13.5px;
    }

    .meta {
      margin-top: 10px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      color: var(--muted);
      font-size: 12.5px;
    }

    .chiprow { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 10px; }
    .chip {
      display: inline-block;
      border: 1px solid var(--border);
      background: var(--soft);
      padding: 5px 8px;
      border-radius: 999px;
      font-size: 12px;
      color: #222;
      white-space: nowrap;
    }

    section {
      margin-top: 14px;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px 16px;
      background: #fff;
    }

    h2 {
      margin: 0 0 10px;
      font-size: 16.5px;
    }

    h3 {
      margin: 14px 0 8px;
      font-size: 14px;
    }

    p { margin: 10px 0; }

    ul { margin: 8px 0 8px 20px; padding: 0; }
    li { margin: 6px 0; }

    .callout {
      border: 1px solid var(--border);
      background: var(--soft);
      border-radius: 10px;
      padding: 12px 12px;
      margin: 10px 0;
    }

    .callout b { display: inline-block; margin-bottom: 6px; }

    code, pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
    }

    pre {
      margin: 10px 0;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--codebg);
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .two {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .hr {
      height: 1px;
      background: var(--border);
      border: 0;
      margin: 12px 0;
    }

    .mini {
      font-size: 12.5px;
      color: var(--muted);
    }

    /* Print styling for A4 */
    @page {
      size: A4;
      margin: 14mm 14mm 16mm 14mm;
    }

    @media print {
      body { background: #fff; }
      .page { padding: 0; }
      header, section { box-shadow: none !important; }
      a { color: inherit; text-decoration: none; }
      a[href]::after { content: ""; } /* prevent printing URL after links */
      pre { page-break-inside: avoid; }
      section { break-inside: avoid-page; }
    }
  </style>
</head>
<body>
  <main class="page">
    <header>
      <h1>âš¡ React Performance â€” Donâ€™t Optimize Prematurely</h1>
      <p class="subtitle">Reviewer / Study Guide (Beginner-Friendly) â€” Focus: Practical Doâ€™s & Donâ€™ts</p>
      <div class="meta">
        <div>ğŸ§  Main idea: Only optimize when thereâ€™s an actual performance problem you can measure or clearly see.</div>
        <div>ğŸ§° Tools referenced: Profiler, <code>memo</code>, <code>useMemo</code>, <code>useCallback</code>, Context optimization, Code splitting.</div>
      </div>
      <div class="chiprow" aria-label="keywords">
        <span class="chip">ğŸš« Premature optimization</span>
        <span class="chip">ğŸ“Š React Profiler</span>
        <span class="chip">ğŸ§© memo / useMemo / useCallback</span>
        <span class="chip">ğŸ§  Context re-renders</span>
        <span class="chip">ğŸ“¦ Code splitting</span>
      </div>
    </header>

    <section>
      <h2>ğŸ¯ í•µì‹¬ ë©”ì‹œì§€ (Core Message)</h2>
      <div class="callout">
        <b>âœ… Rule of thumb:</b>
        <div>Donâ€™t optimize anything if thereâ€™s nothing to optimize.</div>
      </div>

      <ul>
        <li>ğŸ™‚ If your UI feels smooth and responsive, avoid adding memoization â€œjust because.â€</li>
        <li>âš ï¸ Overusing <code>memo</code>, <code>useMemo</code>, and <code>useCallback</code> can <b>hurt</b> performance and make code messy.</li>
        <li>ğŸ§© Context does <b>not</b> need optimization unless itâ€™s causing real, frequent re-renders and the app is visibly slow.</li>
      </ul>

      <div class="callout">
        <b>ğŸ’¡ Why can â€œtoo much memoizationâ€ be bad?</b>
        <ul>
          <li>Memoization has overhead: React needs to compare inputs (props/deps) and keep cached values in memory.</li>
          <li>Thousands of â€œuselessâ€ <code>useMemo</code>/<code>useCallback</code> calls add up.</li>
          <li>Code readability drops: harder maintenance and more bugs.</li>
        </ul>
      </div>
    </section>

    <section>
      <h2>ğŸ” What To Do Instead</h2>
      <h3>1) Look for real bottlenecks</h3>
      <ul>
        <li>ğŸ‘€ Best signal: the UI is laggy, sluggish, delayed (typing feels slow, clicks feel delayed).</li>
        <li>ğŸ“Š Use the React DevTools <b>Profiler</b> to confirm which components are slow and why they render.</li>
      </ul>

      <h3>2) Optimize only what is expensive</h3>
      <ul>
        <li>ğŸ§± Expensive re-render: a component that takes long to render (large lists, heavy calculations).</li>
        <li>ğŸ§® Expensive recalculation: derived computations repeated every render.</li>
      </ul>

      <div class="callout">
        <b>âœ… Healthy workflow</b>
        <ol>
          <li>Reproduce the lag (visual).</li>
          <li>Profile it (measure).</li>
          <li>Optimize the slow part (targeted fix).</li>
          <li>Re-profile to confirm improvement.</li>
        </ol>
      </div>
    </section>

    <section>
      <h2>ğŸ§© Memoization Tools â€” When They Make Sense</h2>
      <div class="two">
        <div class="callout">
          <b>ğŸ§± <code>memo(Component)</code> â€” memoize a component</b>
          <ul>
            <li>Prevents re-render when parent re-renders <b>if props are the same</b>.</li>
            <li>Good for: heavy component + frequent renders + same props often.</li>
          </ul>
        </div>

        <div class="callout">
          <b>ğŸ§  <code>useMemo</code> / <code>useCallback</code> â€” memoize values & functions</b>
          <ul>
            <li>Use when you pass <b>objects/functions</b> to memoized children (stabilize props).</li>
            <li>Use when avoiding expensive recalculation.</li>
            <li>Use when a value/function is in dependencies and causes loops.</li>
          </ul>
        </div>
      </div>

      <hr class="hr" />

      <h3>âœ… Example: Donâ€™t wrap everything in <code>useCallback</code></h3>
      <p class="mini">Only do it when it prevents real wasted renders or solves a real dependency-loop bug.</p>
      <pre><code>// âŒ Anti-pattern: wrapping every function for no reason
const onClick = useCallback(() =&gt; {
  setOpen(true);
}, []);

// âœ… Prefer the simple version unless you proved it fixes a real issue
const onClick = () =&gt; setOpen(true);
</code></pre>

      <h3>âœ… Example: Stabilize an object prop for a memoized child</h3>
      <pre><code>// Parent
const options = useMemo(() =&gt; ({
  show: true,
  title: `Archive (${posts.length})`,
}), [posts.length]);

return &lt;Archive options={options} /&gt;;
</code></pre>

      <h3>âœ… Example: Stabilize a callback prop for a memoized child</h3>
      <pre><code>// Parent
const handleAdd = useCallback(() =&gt; {
  // uses setState (stable) or uses values listed in deps
  setPosts(p =&gt; [...p, makePost()]);
}, []);

return &lt;Archive onAdd={handleAdd} /&gt;;
</code></pre>
    </section>

    <section>
      <h2>ğŸ§  Context API â€” When (and How) to Optimize</h2>
      <div class="callout">
        <b>âœ… Only optimize Context if ALL are true:</b>
        <ul>
          <li>ğŸ” Context state changes frequently</li>
          <li>ğŸ‘¥ Many consumers subscribe to it</li>
          <li>ğŸ¢ App is noticeably slow/laggy</li>
        </ul>
      </div>

      <h3>Common optimization strategies</h3>
      <ul>
        <li>ğŸ§· Memoize the context <b>value</b> object (avoid recreating it on unrelated re-renders).</li>
        <li>ğŸ§± Memoize direct children of a provider (or pass children into provider so React can bail out).</li>
        <li>ğŸ§© Split contexts:
          <ul>
            <li>One context for state, another for updates/dispatch.</li>
            <li>Or separate contexts per â€œdomainâ€ (e.g., posts vs searchQuery).</li>
          </ul>
        </li>
      </ul>

      <h3>âœ… Example: Memoize context value</h3>
      <pre><code>const value = useMemo(() =&gt; ({
  posts,
  searchQuery,
  addPost,
  deletePost,
}), [posts, searchQuery, addPost, deletePost]);

return (
  &lt;PostContext.Provider value={value}&gt;
    {children}
  &lt;/PostContext.Provider&gt;
);
</code></pre>

      <div class="callout">
        <b>âš ï¸ Reminder:</b>
        <div>If <code>addPost</code>/<code>deletePost</code> are recreated each render, then <code>value</code> changes anyway. If needed, wrap those functions in <code>useCallback</code> (but only if proven necessary).</div>
      </div>
    </section>

    <section>
      <h2>ğŸ“Š Profiler Checklist â€” What to Look For</h2>
      <ul>
        <li>ğŸ¥ Record while reproducing the lag (typing, clicking, navigation).</li>
        <li>ğŸ”¥ Identify which component has the biggest render time (Ranked view helps).</li>
        <li>ğŸ§¾ Check â€œWhy did this render?â€
          <ul>
            <li>State change</li>
            <li>Context change</li>
            <li>Parent re-render</li>
          </ul>
        </li>
        <li>ğŸ›  Apply one targeted fix (e.g., <code>memo</code> a heavy child, stabilize props with <code>useMemo</code>/<code>useCallback</code>).</li>
        <li>âœ… Re-record to verify improvement.</li>
      </ul>

      <div class="callout">
        <b>ğŸ¯ Practical rule:</b>
        <div>Prefer fixing the biggest slow component first. Donâ€™t spread â€œmicro-optimizationsâ€ everywhere.</div>
      </div>
    </section>

    <section>
      <h2>ğŸ“¦ Always Do This: Code Splitting + Lazy Loading</h2>
      <div class="callout">
        <b>âœ… Strong recommendation:</b>
        <div>Implement code splitting and lazy loading for routes in SPAs.</div>
      </div>

      <p>
        ğŸš€ This is often the biggest real-world performance win because it reduces how much JavaScript users must download before the app becomes usable.
      </p>

      <h3>âœ… Example: Route-level lazy loading</h3>
      <pre><code>import { Suspense, lazy } from "react";
import SpinnerFullPage from "./components/SpinnerFullPage";

const Home = lazy(() =&gt; import("./pages/Home"));
const Login = lazy(() =&gt; import("./pages/Login"));

export default function App() {
  return (
    &lt;Suspense fallback={&lt;SpinnerFullPage /&gt;}&gt;
      {/* routes here */}
      &lt;Home /&gt;
    &lt;/Suspense&gt;
  );
}
</code></pre>

      <h3>ğŸ§ª Quick verification</h3>
      <ul>
        <li>Use Network throttling (e.g., Slow 3G) to see fallback spinners.</li>
        <li>Run <code>npm run build</code> and verify multiple chunks are output (instead of one huge bundle).</li>
      </ul>
    </section>

    <section>
      <h2>âœ… Quick Doâ€™s & Donâ€™ts Summary</h2>
      <div class="two">
        <div class="callout">
          <b>âœ… Do</b>
          <ul>
            <li>Use the Profiler to find real bottlenecks ğŸ“Š</li>
            <li>Optimize only slow/heavy parts ğŸ¯</li>
            <li>Memoize expensive re-renders/calculations when needed ğŸ§ </li>
            <li>Optimize Context only when itâ€™s actually a problem ğŸ§©</li>
            <li>Always implement route-level lazy loading ğŸ“¦</li>
          </ul>
        </div>
        <div class="callout">
          <b>âŒ Donâ€™t</b>
          <ul>
            <li>Memo everything â€œby defaultâ€ ğŸš«</li>
            <li>Use thousands of <code>useMemo</code>/<code>useCallback</code> â€œjust in caseâ€ ğŸ§¨</li>
            <li>Optimize Context when the app is already fast ğŸ‡</li>
            <li>Sacrifice readability for tiny gains ğŸ§¯</li>
          </ul>
        </div>
      </div>

      <p class="mini">
        â­ If you remember only one thing: optimize when you can see or measure a problem, not before.
      </p>
    </section>
  </main>
</body>
</html>
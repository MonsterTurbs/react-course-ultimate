

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>React Performance ‚Äî Optimizing Context Re-Renders (Study Guide)</title>
  <style>
    :root {
      --bg: #ffffff;
      --text: #111111;
      --muted: #555555;
      --border: #e6e6e6;
      --soft: #fafafa;
      --accent: #0b57d0;
      --good: #0f7b3e;
      --warn: #8a4b00;
      --bad: #b00020;
      --codebg: #0b0f19;
      --codetext: #e8eefc;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.6;
      overflow-wrap: anywhere;
      word-break: break-word;
    }

    /* Single-column page */
    .page {
      max-width: 860px;
      margin: 0 auto;
      padding: 28px 20px 40px;
    }

    header {
      padding-bottom: 14px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 18px;
    }

    h1 {
      font-size: 1.6rem;
      margin: 0 0 6px;
      letter-spacing: -0.2px;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 0.98rem;
    }

    .meta {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .chip {
      display: inline-block;
      border: 1px solid var(--border);
      background: var(--soft);
      padding: 4px 10px;
      border-radius: 999px;
      white-space: nowrap;
    }

    section {
      padding: 14px 0;
      border-bottom: 1px solid var(--border);
    }

    h2 {
      font-size: 1.25rem;
      margin: 0 0 10px;
      letter-spacing: -0.2px;
    }

    h3 {
      font-size: 1.05rem;
      margin: 14px 0 8px;
    }

    p { margin: 0 0 10px; }

    ul {
      margin: 8px 0 12px 20px;
      padding: 0;
    }

    li { margin: 6px 0; }

    .callout {
      border: 1px solid var(--border);
      background: var(--soft);
      padding: 12px 12px;
      border-radius: 10px;
      margin: 10px 0 12px;
    }

    .callout strong { display: inline-block; margin-bottom: 4px; }

    .callout.good { border-color: rgba(15, 123, 62, 0.25); }
    .callout.warn { border-color: rgba(138, 75, 0, 0.25); }
    .callout.bad  { border-color: rgba(176, 0, 32, 0.25); }

    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95em;
      padding: 1px 6px;
      border: 1px solid var(--border);
      border-bottom-width: 2px;
      border-radius: 6px;
      background: #fff;
      white-space: nowrap;
    }

    pre {
      margin: 10px 0 14px;
      padding: 12px 12px;
      background: var(--codebg);
      color: var(--codetext);
      border-radius: 10px;
      overflow: auto;
      line-height: 1.5;
    }

    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95em;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .mini {
      font-size: 0.94rem;
      color: var(--muted);
    }

    .divider {
      height: 1px;
      background: var(--border);
      margin: 12px 0;
    }

    a { color: var(--accent); text-decoration: underline; text-underline-offset: 2px; }

    /* Print (A4) */
    @page { size: A4; margin: 14mm; }

    @media print {
      body { font-size: 11.5pt; }
      .page { max-width: none; padding: 0; }
      header { margin-bottom: 12px; }
      section { break-inside: avoid; }
      pre { break-inside: avoid; }
      a, a:visited { color: inherit; text-decoration: none; }
      a[href]:after { content: ""; } /* do not print URLs */
      .chip { background: #fff; }
    }
  </style>
</head>
<body>
  <main class="page">
    <header>
      <h1>Optimizing Context Re-Renders (React Performance)</h1>
      <p class="subtitle">Reviewer / study guide based on the lecture transcript ‚Äî beginner-friendly with practical patterns, pitfalls, and code examples.</p>
      <div class="meta">
        <span class="chip">üß† Topic: Context API + performance</span>
        <span class="chip">üß∞ Tools: Profiler, <code>memo</code>, <code>useMemo</code>, <code>useCallback</code></span>
        <span class="chip">üéØ Goal: Reduce wasted renders</span>
      </div>
    </header>

    <section>
      <h2>Big idea</h2>
      <p>Context is convenient, but it can trigger <strong>wide re-renders</strong> if you are not careful. The key is to understand <em>when</em> context causes re-renders and to apply optimizations only when they are truly needed.</p>

      <div class="callout warn">
        <strong>‚ö†Ô∏è Optimize context only when ALL 3 are true</strong>
        <ul>
          <li>üîÅ The context state changes frequently (e.g., typing, scrolling, polling).</li>
          <li>üë• The context has many consumers (many components read it).</li>
          <li>üê¢ The app is noticeably slow/laggy (confirmed with the Profiler).</li>
        </ul>
        <p class="mini">If any of these is false, optimization often adds complexity without real benefit.</p>
      </div>
    </section>

    <section>
      <h2>Quick refresher: why context can re-render many components</h2>
      <p>Any component that <strong>subscribes</strong> to a context (via <code>useContext</code> or a custom hook like <code>usePosts()</code>) will re-render when the <strong>context value changes</strong>.</p>
      <div class="callout">
        <strong>‚úÖ What counts as ‚Äúcontext value changed‚Äù?</strong>
        <p>Usually your provider passes an <strong>object</strong> like:</p>
        <pre><code>const value = {
  posts,
  searchQuery,
  searchedPosts,
  onAddPost,
  onClearPosts,
};</code></pre>
        <p class="mini">If this object is recreated (new reference), React considers the context ‚Äúchanged‚Äù ‚Äî even if the contents look the same.</p>
      </div>
    </section>

    <section>
      <h2>Strategy 1: ‚ÄúChildren optimization‚Äù (passing children into Provider)</h2>
      <p>One simple optimization is to structure your provider so it receives UI as <code>children</code>. This can prevent some components from re-rendering when the provider updates (unless they consume the context).</p>

      <div class="grid">
        <div class="callout good">
          <strong>‚úÖ Good pattern</strong>
          <pre><code>function PostProvider({ children }) {
  const [posts, setPosts] = useState([]);

  return (
    &lt;PostContext.Provider value={{ posts, setPosts }}&gt;
      {children}
    &lt;/PostContext.Provider&gt;
  );
}

// App renders children *outside* provider creation
&lt;PostProvider&gt;
  &lt;Header /&gt;
  &lt;Main /&gt;
  &lt;Footer /&gt;
&lt;/PostProvider&gt;</code></pre>
          <p class="mini">Some children may ‚Äúbail out‚Äù of re-rendering because they were created before being passed in.</p>
        </div>

        <div class="callout warn">
          <strong>üìù Important note</strong>
          <p>This does <strong>not</strong> stop re-renders of components that actually consume the context. Subscribers still re-render when context changes.</p>
        </div>
      </div>
    </section>

    <section>
      <h2>Strategy 2: Memoize direct descendants of the Provider</h2>
      <p>If you are <em>not</em> using the ‚Äúchildren optimization‚Äù (or your structure prevents it), consider memoizing the direct child components under the provider.</p>

      <div class="callout">
        <strong>‚úÖ Idea</strong>
        <p>Wrap heavy direct descendants with <code>memo</code> so they don‚Äôt re-render just because the provider re-rendered.</p>
        <pre><code>import { memo } from "react";

const Main = memo(function Main() {
  return &lt;main&gt;...&lt;/main&gt;;
});</code></pre>
        <p class="mini">This helps only when the component‚Äôs props stay stable and it does not subscribe to changing context values.</p>
      </div>
    </section>

    <section>
      <h2>Strategy 3: Memoize the Provider ‚Äúvalue‚Äù object</h2>
      <p>This is a very common and very important one. If your provider returns an object literal, it gets recreated every provider render ‚Äî which can cause <strong>all consumers</strong> to re-render.</p>

      <h3>Problem scenario</h3>
      <p>Even if state changes happen <em>above</em> the provider (like a ‚Äúdark mode‚Äù toggle in <code>App</code>), the provider re-renders and the value object is recreated:</p>
      <pre><code>// ‚ùå Recreated on every render
const value = {
  posts,
  searchQuery,
  searchedPosts,
  handleAddPost,
  clearPosts,
};

return (
  &lt;PostContext.Provider value={value}&gt;
    {children}
  &lt;/PostContext.Provider&gt;
);</code></pre>

      <h3>Fix with <code>useMemo</code></h3>
      <pre><code>import { useMemo } from "react";

const value = useMemo(() =&gt; {
  return {
    posts,
    searchQuery,
    searchedPosts,
    handleAddPost,
    clearPosts,
  };
}, [posts, searchQuery, searchedPosts, handleAddPost, clearPosts]);</code></pre>

      <div class="callout warn">
        <strong>‚ö†Ô∏è Common trap: functions inside the value</strong>
        <p>If you include functions (like <code>handleAddPost</code>) and they are recreated each render, then the dependency array changes each render‚Ä¶ and your memoized value becomes useless.</p>
      </div>

      <h3>Stabilize functions with <code>useCallback</code></h3>
      <pre><code>import { useCallback, useMemo } from "react";

const handleAddPost = useCallback((newPost) =&gt; {
  setPosts((posts) =&gt; [newPost, ...posts]);
}, []);

const clearPosts = useCallback(() =&gt; {
  setPosts([]);
}, []);

const value = useMemo(() =&gt; {
  return {
    posts,
    searchQuery,
    searchedPosts,
    handleAddPost,
    clearPosts,
  };
}, [posts, searchQuery, searchedPosts, handleAddPost, clearPosts]);</code></pre>

      <div class="callout good">
        <strong>‚úÖ Why this helps</strong>
        <ul>
          <li>üßä The provider value becomes <strong>stable</strong> across renders when nothing relevant changed.</li>
          <li>üéØ Consumers won‚Äôt re-render due to ‚Äúfake‚Äù context changes caused by new object references.</li>
        </ul>
      </div>

      <div class="callout">
        <strong>üí° Note about state setters</strong>
        <p><code>setState</code> functions from <code>useState</code> have a <strong>stable identity</strong> in React, so they typically don‚Äôt need to be added to dependency arrays.</p>
      </div>
    </section>

    <section>
      <h2>Strategy 4: Split context to reduce ‚Äúblast radius‚Äù</h2>
      <p>If your context value contains many different pieces of state, then changing <em>any one</em> piece will re-render <em>all</em> consumers that read from that context.</p>

      <div class="callout warn">
        <strong>‚ö†Ô∏è Symptom</strong>
        <p>You update <code>searchQuery</code>, and components that only care about <code>posts</code> still re-render, because everything is bundled into a single context value.</p>
      </div>

      <h3>Option A: One context per concern</h3>
      <pre><code>// Example split
&lt;PostsProvider&gt;
  &lt;SearchProvider&gt;
    &lt;App /&gt;
  &lt;/SearchProvider&gt;
&lt;/PostsProvider&gt;</code></pre>
      <p class="mini">Now updating search does not automatically re-render components that only subscribe to posts.</p>

      <h3>Option B: Split ‚Äústate‚Äù vs ‚Äúactions‚Äù (or dispatch)</h3>
      <p>Advanced pattern: one context for state and another for actions (or <code>dispatch</code>), so components can subscribe only to what they need.</p>
      <pre><code>// Example idea (conceptual)
const PostsStateContext = createContext();
const PostsDispatchContext = createContext();</code></pre>

      <div class="callout">
        <strong>üß© Practical guidance</strong>
        <ul>
          <li>Start simple. Split only when the profiler proves it matters.</li>
          <li>If you use <code>useReducer</code>, splitting state vs dispatch is often a clean improvement.</li>
        </ul>
      </div>
    </section>

    <section>
      <h2>Profiler workflow</h2>
      <p>Use the Profiler to confirm if an optimization is real (not just ‚Äúfeels faster‚Äù).</p>
      <ol style="margin: 8px 0 12px 20px;">
        <li>Open React DevTools ‚Üí <strong>Profiler</strong>.</li>
        <li>Enable: <span class="kbd">Record why each component rendered</span>.</li>
        <li>Click <strong>Record</strong>, perform one action (type, click toggle), then <strong>Stop</strong>.</li>
        <li>Check: Which components re-rendered, and why (state / context / parent)?</li>
      </ol>

      <div class="callout good">
        <strong>‚úÖ ‚ÄúWin condition‚Äù</strong>
        <p>After memoizing <code>value</code> and stabilizing functions, components should stop re-rendering due to ‚Äúcontext changed‚Äù when nothing relevant actually changed.</p>
      </div>

      <div class="callout warn">
        <strong>‚ö†Ô∏è Keep expectations realistic</strong>
        <p>If the context state itself changes (e.g., you truly update <code>posts</code>), consumers will still re-render. That‚Äôs correct behavior.</p>
      </div>
    </section>

    <section style="border-bottom: 0; padding-bottom: 0;">
      <h2>Cheat sheet</h2>
      <ul>
        <li>üß† Context re-renders consumers when <strong>value reference changes</strong>.</li>
        <li>üßí Passing UI as <code>children</code> into providers can reduce re-renders for non-consumers.</li>
        <li>üßä Memoize the provider <code>value</code> with <code>useMemo</code> when parent renders recreate it.</li>
        <li>ü™ù Stabilize functions inside value with <code>useCallback</code>, otherwise <code>useMemo</code> won‚Äôt help.</li>
        <li>üß© Split contexts if one context holds too many unrelated state values and you have many consumers.</li>
        <li>üìä Always verify with the Profiler before and after.</li>
      </ul>

      <div class="divider"></div>
      <p class="mini">End of notes ‚Äî next topic usually continues with deeper context optimization patterns and more advanced hooks.</p>
    </section>
  </main>
</body>
</html>
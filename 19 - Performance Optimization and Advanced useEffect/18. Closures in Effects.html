

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>React â€” Closures in Effects (Sound on Duration Change) | Study Guide</title>
  <style>
    :root{
      --bg:#ffffff;
      --text:#111111;
      --muted:#5a5a5a;
      --border:#e6e6e6;
      --soft:#f7f7f7;
      --accent:#0b57d0;
      --good:#0f7b34;
      --warn:#8a4b00;
      --bad:#b00020;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: Arial, Helvetica, sans-serif;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      background:var(--bg);
      color:var(--text);
      line-height:1.6;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* Single-column layout */
    .page{
      max-width: 900px;
      margin: 0 auto;
      padding: 28px 22px;
    }

    header{
      border:1px solid var(--border);
      background: #fff;
      padding: 16px 16px;
      border-radius: 10px;
    }
    h1{ margin:0 0 6px; font-size: 1.55rem; letter-spacing: .2px; }
    .subtitle{ margin:0; color:var(--muted); }

    .meta{
      margin-top:10px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .chip{
      display:inline-block;
      padding:6px 10px;
      border:1px solid var(--border);
      background:var(--soft);
      border-radius:999px;
      font-size:.9rem;
      color:#1b1b1b;
      white-space:nowrap;
    }

    main{ margin-top: 16px; }

    section{
      margin: 14px 0;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px 16px;
      background:#fff;
      break-inside: avoid;
      page-break-inside: avoid;
    }

    h2{ margin:0 0 8px; font-size:1.25rem; }
    h3{ margin: 12px 0 6px; font-size:1.05rem; }
    p{ margin: 8px 0; }

    ul{ margin: 8px 0 8px 22px; padding:0; }
    li{ margin: 6px 0; }

    .callout{
      border-left: 5px solid var(--accent);
      background: #f3f7ff;
      padding: 10px 12px;
      border-radius: 8px;
      margin: 10px 0;
    }
    .callout.good{ border-left-color: var(--good); background:#f0fff6; }
    .callout.warn{ border-left-color: var(--warn); background:#fff7ed; }
    .callout.bad{ border-left-color: var(--bad); background:#fff2f2; }

    .k{ font-family: var(--mono); font-size: .95rem; }

    pre{
      margin: 10px 0;
      padding: 12px;
      border: 1px solid var(--border);
      background: #fcfcfc;
      border-radius: 10px;
      overflow:auto;
      font-family: var(--mono);
      font-size: .92rem;
      line-height: 1.5;
      white-space: pre-wrap;
      word-break: break-word;
    }

    code{ font-family: var(--mono); font-size: .95em; }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .rule{
      border: 1px dashed var(--border);
      background: var(--soft);
      padding: 10px 12px;
      border-radius: 10px;
    }

    .mini{
      font-size: .95rem;
      color: var(--muted);
    }

    /* Print styles */
    @page{
      size: A4;
      margin: 14mm 14mm;
    }
    @media print{
      body{ background:#fff; }
      .page{ max-width:none; padding:0; }
      header, section{ border-color:#d9d9d9; box-shadow:none; }
      a{ color:inherit; text-decoration:none; }
      a[href]:after{ content: "" !important; } /* don't print URLs */
      .chip{ background:#fff; }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <h1>ğŸ”Š Closures in Effects: â€œPlay Sound When Duration Changesâ€</h1>
      <p class="subtitle">Advanced <code>useEffect</code> lesson â€” dependency arrays, helper functions, and avoiding surprising re-renders (beginner-friendly reviewer)</p>
      <div class="meta">
        <span class="chip">React</span>
        <span class="chip">useEffect</span>
        <span class="chip">useCallback</span>
        <span class="chip">Closures</span>
        <span class="chip">Side Effects</span>
      </div>
    </header>

    <main>
      <section>
        <h2>ğŸ¯ Goal of the Lesson</h2>
        <p>We want to <strong>play a click sound</strong> whenever the <strong>duration state</strong> changes in a â€œWorkout Timerâ€ app.</p>
        <ul>
          <li>âœ… Sound should play when duration changes (from buttons or calculated updates).</li>
          <li>âœ… Sound should respect a toggle like <code>allowSound</code> (mute/unmute).</li>
          <li>âŒ Avoid bugs like: sound playing twice, duration â€œflickeringâ€, or duration being reset unexpectedly.</li>
        </ul>
        <div class="callout warn">
          <strong>Heads-up ğŸ™‚</strong> This lesson looks simple ("play a sound"), but it exposes multiple real React pitfalls: <strong>reactive values</strong>, <strong>function identity</strong>, and <strong>effect re-runs</strong>.
        </div>
      </section>

      <section>
        <h2>ğŸ§  Key Concepts You Must Know</h2>
        <div class="grid">
          <div class="rule">
            <h3>1) Reactive values</h3>
            <p>Reactive values are anything that can change across renders:</p>
            <ul>
              <li>State: <code>duration</code>, <code>allowSound</code>, etc.</li>
              <li>Props: props that come from state are also reactive.</li>
              <li>Context values: any subscribed context value is reactive.</li>
              <li><strong>Functions that reference reactive values</strong> become reactive too.</li>
            </ul>
          </div>

          <div class="rule">
            <h3>2) Function identity (why â€œsame codeâ€ can still be â€œnewâ€)</h3>
            <p>In JavaScript, <strong>functions are objects</strong>. If you create a function inside a component, React recreates it on every render:</p>
            <pre><code>function App() {
  function playSound() { /* ... */ }
  // ğŸ‘† This is re-created on every render
}</code></pre>
            <p class="mini">Meaning: React may treat it as â€œchangedâ€ even if the function body looks identical.</p>
          </div>

          <div class="rule">
            <h3>3) Effects re-run when dependencies change</h3>
            <p>React checks dependencies with <code>Object.is</code>/<code>===</code>-like behavior. For objects/functions, reference changes trigger re-run.</p>
            <div class="callout good">
              âœ… If you include all reactive deps, you avoid <strong>stale closures</strong>.
            </div>
            <div class="callout bad">
              âŒ But if a dependency changes every render (like a newly created function), the effect can run too often and break logic.
            </div>
          </div>
        </div>
      </section>

      <section>
        <h2>ğŸ”‰ Step 1: Playing a Sound (Browser Audio API)</h2>
        <p>The lesson uses a sound file and the browserâ€™s Audio API:</p>
        <pre><code>// Example idea (not exact file paths)
import clickSound from "./click.mp3";

function playSound() {
  const sound = new Audio(clickSound);
  sound.play();
}</code></pre>
        <div class="callout warn">
          <strong>Common browser rule âš ï¸</strong> Browsers often block autoplay audio until the user interacts (click, keypress). So your console may show warnings before the first user action.
        </div>
      </section>

      <section>
        <h2>ğŸ§© The First â€œNaiveâ€ Implementation (and Why It Breaks)</h2>
        <p>You might try to call <code>playSound()</code> in multiple places:</p>
        <ul>
          <li>Inside <code>handleInc()</code> and <code>handleDec()</code> (manual duration changes)</li>
          <li>Inside the <code>useEffect</code> that recalculates duration based on other state inputs</li>
        </ul>
        <p>But then ESLint complains: <code>playSound</code> is a reactive value (it uses <code>allowSound</code>), so you add it to the dependency array:</p>
        <pre><code>useEffect(() =&gt; {
  setDuration(/* compute based on inputs */);
}, [number, sets, speed, breakDuration, playSound]);</code></pre>

        <div class="callout bad">
          <strong>Bug symptom ğŸ˜µ</strong>
          <ul>
            <li>Clicking + / - causes <strong>duration flicker</strong> (changes, then instantly resets).</li>
            <li>Sound may play <strong>twice</strong>.</li>
          </ul>
        </div>

        <h3>âœ… Why it happens (clear mental model)</h3>
        <ol>
          <li>You click + â†’ duration updates â†’ component re-renders.</li>
          <li>Re-render recreates <code>playSound</code> (new function reference).</li>
          <li>Effect sees dependency <code>playSound</code> changed â†’ effect runs again.</li>
          <li>Effect recalculates duration from inputs (which did NOT change) â†’ resets duration back.</li>
        </ol>
        <p><strong>So the dependency wasnâ€™t â€œwrongâ€</strong>. The dependency was correct â€” but the design caused the effect to run at the wrong times.</p>
      </section>

      <section>
        <h2>ğŸ› ï¸ Attempted Fix: Memoize the Helper Function with <code>useCallback</code></h2>
        <p>Since <code>playSound</code> depends on <code>allowSound</code>, we cannot move it outside the component. Another strategy is to memoize it:</p>
        <pre><code>const playSound = useCallback(() =&gt; {
  if (!allowSound) return;
  const sound = new Audio(clickSound);
  sound.play();
}, [allowSound]);</code></pre>

        <div class="callout good">
          âœ… Now <code>playSound</code> stays stable between renders <em>unless</em> <code>allowSound</code> changes.
        </div>

        <h3>ğŸ¤” New surprising behavior</h3>
        <p>When you toggle sound on/off, the sound may play when turning it <em>on</em>.</p>
        <ul>
          <li>Because changing <code>allowSound</code> recreates <code>playSound</code></li>
          <li>Which can re-trigger effects that depend on <code>playSound</code></li>
        </ul>

        <div class="callout warn">
          <strong>Important lesson ğŸ§ </strong> Memoization fixes identity problems, but if your effect responsibilities are mixed ("set duration" + "play sound"), you can still get confusing chains of re-renders.
        </div>
      </section>

      <section>
        <h2>âœ… Best Practice Fix: One Effect Per Side Effect</h2>
        <p>The clean solution is to make the code more <strong>intentional</strong>:</p>
        <ul>
          <li>Effect A: only recalculates <code>duration</code> when inputs change.</li>
          <li>Effect B: only plays a sound when <code>duration</code> changes.</li>
        </ul>

        <h3>Effect A â€” keep duration synchronized with inputs</h3>
        <pre><code>useEffect(() =&gt; {
  setDuration(/* compute based on number, sets, speed, breakDuration */);
}, [number, sets, speed, breakDuration]);</code></pre>

        <h3>Effect B â€” play a sound when duration changes</h3>
        <pre><code>function playSound() {
  if (!allowSound) return;
  const sound = new Audio(clickSound);
  sound.play();
}

useEffect(() =&gt; {
  // We WANT this to run when duration changes
  playSound();
}, [duration, allowSound]);</code></pre>

        <div class="callout good">
          <strong>Why this is better âœ…</strong>
          <ul>
            <li>No more calling sound from multiple places.</li>
            <li>No more â€œduration resetâ€ when toggling sound.</li>
            <li>Each effect has a single responsibility â†’ easier to reason about and debug.</li>
          </ul>
        </div>

        <div class="callout warn">
          <strong>Note ğŸ™‚</strong> Itâ€™s okay that <code>duration</code> is in the dependency array even if you donâ€™t read it directly inside the effect body. Youâ€™re using it as a â€œtriggerâ€ to synchronize a side effect with that state.
        </div>
      </section>

      <section>
        <h2>ğŸ§ª Debug Checklist (When Your Effect â€œFeels Hauntedâ€)</h2>
        <ul>
          <li>ğŸ” Is an effect re-running because a dependency changes every render (object/function)?</li>
          <li>ğŸ§  Are you mixing multiple responsibilities inside one effect?</li>
          <li>ğŸ§· Are helper functions defined in the component body that reference state/props?</li>
          <li>ğŸ“¦ Can you move the helper function <em>outside</em> the component? If not, can you move it <em>inside</em> the effect?</li>
          <li>ğŸ§° If you need the helper in multiple places, should it be stabilized via <code>useCallback</code>?</li>
        </ul>
      </section>

      <section>
        <h2>âš ï¸ Common Mistakes and How to Avoid Them</h2>
        <ul>
          <li>âŒ <strong>Omitting dependencies</strong> to â€œmake the warning go awayâ€ â†’ leads to stale closures and bugs.</li>
          <li>âŒ Putting objects/functions in dependencies without stabilizing them â†’ effect runs too often.</li>
          <li>âŒ Calling the same side effect (sound) from multiple places â†’ duplicated triggers and unpredictable behavior.</li>
          <li>âœ… Prefer: <strong>separate effects</strong> and <strong>explicit triggers</strong> (like <code>[duration]</code>).</li>
        </ul>
      </section>

      <section>
        <h2>ğŸ“ Quick Self-Test (Retention)</h2>
        <ol>
          <li>Why did adding <code>playSound</code> to the dependency array cause the duration to reset when clicking + / -?</li>
          <li>When is <code>useCallback</code> a good solution for helper functions?</li>
          <li>What does â€œone effect per side effectâ€ mean in practice?</li>
          <li>Why can browsers block playing audio on the first render?</li>
        </ol>
        <p class="mini">If you can answer these without looking, youâ€™ve internalized the core lesson.</p>
      </section>

      <section>
        <h2>âœ… Key Takeaways</h2>
        <ul>
          <li>ğŸ¯ Dependencies are not â€œoptionalâ€; they prevent stale closures.</li>
          <li>ğŸ§¬ Functions created inside a component can be <strong>new</strong> each render â†’ can trigger effects.</li>
          <li>ğŸ§° Use <code>useCallback</code> when you truly need stable function identity.</li>
          <li>ğŸ§¼ The cleanest solution is often structural: <strong>separate your effects</strong> so each one does one job.</li>
        </ul>
      </section>

      <section>
        <h2>ğŸ“Œ Practical Pattern to Copy</h2>
        <pre><code>// Pattern: "state sync" effect + "side-effect sync" effect

// 1) Sync derived state
useEffect(() =&gt; {
  setDuration(/* derive duration from inputs */);
}, [number, sets, speed, breakDuration]);

// 2) Sync side effect to one state
useEffect(() =&gt; {
  if (!allowSound) return;
  const sound = new Audio(clickSound);
  sound.play();
}, [duration, allowSound]);</code></pre>
        <p class="mini">This is a clean, predictable way to avoid accidental re-trigger chains.</p>
      </section>

    </main>
  </div>
</body>
</html>
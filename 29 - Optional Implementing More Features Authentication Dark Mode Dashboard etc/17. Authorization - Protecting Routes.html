<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>React Study Guide ‚Äî Protected Routes + Current User (Supabase) + React Query Cache</title>
  <style>
    :root{
      --bg:#ffffff;
      --text:#111111;
      --muted:#555555;
      --border:#e6e6e6;
      --panel:#fafafa;
      --chip:#f3f4f6;
      --link:#0b57d0;
      --shadow: 0 8px 30px rgba(0,0,0,.06);

      /* High-contrast code theme */
      --code-bg:#0b1220;
      --code-text:#e6edf3;
      --code-border:#1f2937;
      --inline-bg:#eef2ff;
      --inline-border:#dbeafe;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height:1.65;
      overflow-wrap:anywhere;
      word-break:normal;
    }

    .page{
      max-width: 980px;
      margin: 0 auto;
      padding: 28px 18px 56px;
    }

    header{
      padding: 18px 18px;
      border:1px solid var(--border);
      border-radius: 14px;
      background: linear-gradient(180deg, #fff, var(--panel));
      box-shadow: var(--shadow);
    }

    h1{
      margin: 0 0 8px;
      font-size: 24px;
      letter-spacing: .2px;
      line-height: 1.25;
    }

    .subtitle{
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }

    .toolbar{
      margin-top: 14px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .btn{
      appearance:none;
      border:1px solid var(--border);
      background:#fff;
      border-radius: 10px;
      padding: 9px 12px;
      cursor:pointer;
      font-weight:600;
      font-size: 13px;
    }
    .btn:hover{ border-color:#cfcfcf; }
    .btn:active{ transform: translateY(1px); }

    .meta{
      margin-left:auto;
      color:var(--muted);
      font-size: 12px;
    }

    main{
      margin-top: 18px;
      padding: 18px;
      border:1px solid var(--border);
      border-radius: 14px;
      background:#fff;
      box-shadow: var(--shadow);
    }

    h2{
      margin: 18px 0 10px;
      font-size: 18px;
      line-height: 1.25;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 15px;
      line-height: 1.3;
    }

    p{ margin: 8px 0; }
    ul{ margin: 8px 0 8px 20px; padding:0; }
    li{ margin: 6px 0; }

    .callout{
      border:1px solid var(--border);
      background: var(--panel);
      border-radius: 12px;
      padding: 12px 12px;
      margin: 12px 0;
    }

    .chips{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin: 10px 0 0;
      padding: 0;
      list-style:none;
    }
    .chip{
      background: var(--chip);
      border:1px solid var(--border);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      color:#222;
    }

    .divider{
      height:1px;
      background:var(--border);
      margin: 16px 0;
    }

    .small{ color:var(--muted); font-size: 13px; }

    /* Code blocks */
    code, pre{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
                   "Liberation Mono", "Courier New", monospace;
    }
    code{
      background: var(--inline-bg);
      color:#111111;
      padding: 1px 6px;
      border-radius: 6px;
      border: 1px solid var(--inline-border);
      font-size: 0.95em;
      opacity: 1 !important;
    }
    pre{
      margin: 10px 0;
      padding: 12px 14px;
      border-radius: 12px;
      background: var(--code-bg);
      color: var(--code-text);
      border: 1px solid var(--code-border);
      overflow:auto;
      max-width: 100%;
      box-shadow: 0 2px 14px rgba(0,0,0,.10);
      opacity: 1 !important;
    }
    pre code{
      background: transparent !important;
      border: 0 !important;
      padding: 0 !important;
      border-radius: 0 !important;
      color: inherit !important;
      font-size: 12.8px;
      line-height: 1.6;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
      word-break: break-word;
      opacity: 1 !important;
    }

    @media print{
      @page{ size: A4; margin: 12mm; }
      body{ background:#fff; }
      .page{ padding: 0; margin: 0; max-width: none; }
      header, main{ box-shadow: none; }
      header{ break-inside: avoid; }
      .toolbar{ display:none !important; }
      a[href]::after{ content:""; }

      pre{
        background:#ffffff !important;
        color:#111111 !important;
        border: 1px solid #d0d0d0 !important;
        box-shadow: none !important;
        overflow: visible !important;
      }
      pre code{
        white-space: pre-wrap !important;
        overflow-wrap: anywhere !important;
        word-break: break-word !important;
      }

      .callout{ break-inside: avoid; }
      h2{ break-after: avoid; }
    }
  </style>
</head>

<body>
  <div class="page">
    <header>
      <h1>üõ°Ô∏è Authorization in the UI ‚Äî Protected Route + Current User + React Query</h1>
      <p class="subtitle">
        Goal: only logged-in users can access the app. Implementation: wrap the entire App Layout route with a
        <strong>ProtectedRoute</strong> that loads the current user, shows a spinner, redirects when needed, and renders children only if authenticated.
      </p>

      <div class="toolbar">
        <button class="btn" type="button" onclick="window.print()">üñ®Ô∏è Print / Save as PDF</button>
        <button class="btn" type="button" onclick="window.scrollTo({top:0,behavior:'smooth'})">‚¨ÜÔ∏è Back to Top</button>
        <span class="meta">Single-column ‚Ä¢ A4 print-ready ‚Ä¢ High-contrast code</span>
      </div>

      <ul class="chips" aria-label="key tags">
        <li class="chip">üõ°Ô∏è Protected routes</li>
        <li class="chip">üßë‚Äçüíª Supabase auth</li>
        <li class="chip">‚ö° React Query</li>
        <li class="chip">üß≠ Redirect to login</li>
        <li class="chip">üíæ Session in localStorage</li>
        <li class="chip">üóÉÔ∏è Cache user data</li>
      </ul>
    </header>

    <main>
      <h2>1) Why we need a ProtectedRoute</h2>
      <p>
        Even if you have a login UI, users can still try to access private routes directly (via URL).
        We solve this by wrapping the main app layout in a protected component.
      </p>

      <div class="callout">
        <p><strong>üß© Why wrap the App Layout (not each page)</strong></p>
        <ul>
          <li>All pages are <strong>child routes</strong> of the App Layout route.</li>
          <li>If you protect the layout, you protect <em>all</em> child pages automatically.</li>
          <li>Less duplication, more ‚Äúreal-world‚Äù routing design.</li>
        </ul>
      </div>

      <div class="divider"></div>

      <h2>2) The ProtectedRoute recipe (4 steps)</h2>
      <p>
        The component follows a simple, robust sequence:
      </p>
      <ol>
        <li>üë§ Load the authenticated user</li>
        <li>‚è≥ While loading ‚Üí show a spinner</li>
        <li>üö´ If no user ‚Üí redirect to login</li>
        <li>‚úÖ If user exists ‚Üí render the app (children)</li>
      </ol>

      <pre><code>// ProtectedRoute.jsx (conceptual skeleton)
function ProtectedRoute({ children }) {
  // 1) load user
  // 2) if loading -&gt; spinner
  // 3) if not authenticated -&gt; navigate("/login")
  // 4) else return children
  return children;
}</code></pre>

      <div class="divider"></div>

      <h2>3) Server-side auth check: getCurrentUser (Supabase)</h2>
      <p>
        We need to fetch the current user on page reloads too‚Äînot only right after login.
        That means we must ask Supabase: ‚ÄúIs there still a valid session?‚Äù
      </p>

      <div class="callout">
        <p><strong>üß† Why fetch user again after reload?</strong></p>
        <ul>
          <li>A user might log in today, then reload tomorrow and still expect to be logged in.</li>
          <li>So each refresh should confirm the session and fetch the current user.</li>
        </ul>
      </div>

      <h3>Step A ‚Äî check for an active session</h3>
      <p>
        Supabase can read session data from localStorage via <code>getSession()</code>.
        If no session exists, return <code>null</code> immediately.
      </p>

      <pre><code>// services/apiAuth.js (conceptual)
export async function getCurrentUser() {
  const { data: sessionData } = await supabase.auth.getSession();

  if (!sessionData.session) return null;

  // More secure: refetch user from Supabase
  const { data, error } = await supabase.auth.getUser();
  if (error) throw error;

  return data?.user ?? null;
}</code></pre>

      <div class="callout">
        <p><strong>üîí Security note (from the lecture)</strong></p>
        <p>
          You could read the user from the session object, but it‚Äôs often safer to fetch the user from Supabase again.
        </p>
      </div>

      <div class="divider"></div>

      <h2>4) Use React Query to cache the user: <code>useUser</code></h2>
      <p>
        We store ‚Äúcurrent user‚Äù in React Query cache so it can be reused across the app and across components.
      </p>

      <pre><code>// hooks/useUser.js (conceptual)
import { useQuery } from "@tanstack/react-query";
import { getCurrentUser } from "../services/apiAuth";

export function useUser() {
  const { isLoading, data: user } = useQuery({
    queryKey: ["user"],
    queryFn: getCurrentUser,
  });

  const isAuthenticated = user?.role === "authenticated";

  return { isLoading, user, isAuthenticated };
}</code></pre>

      <div class="callout">
        <p><strong>üìå Why compute <code>isAuthenticated</code> here</strong></p>
        <ul>
          <li>So other components don‚Äôt repeat the same logic.</li>
          <li>Keeps ‚Äúauth meaning‚Äù in one place.</li>
        </ul>
      </div>

      <div class="divider"></div>

      <h2>5) ProtectedRoute logic with spinner + redirect</h2>
      <p>
        ProtectedRoute consumes <code>useUser()</code> and makes decisions:
      </p>

      <ul>
        <li>‚è≥ If loading ‚Üí show full-page spinner (better UX)</li>
        <li>üö´ If not authenticated after loading ‚Üí navigate to login</li>
        <li>‚úÖ If authenticated ‚Üí render children (the app layout + pages)</li>
      </ul>

      <pre><code>// ProtectedRoute.jsx (conceptual)
import { useEffect } from "react";
import { useNavigate } from "react-router-dom";
import styled from "styled-components";
import Spinner from "./Spinner";
import { useUser } from "../hooks/useUser";

const FullPage = styled.div`
  height: 100vh;
  background: var(--color-grey-50);
  display: flex;
  align-items: center;
  justify-content: center;
`;

function ProtectedRoute({ children }) {
  const navigate = useNavigate();
  const { isLoading, isAuthenticated } = useUser();

  useEffect(() =&gt; {
    if (!isAuthenticated &amp;&amp; !isLoading) navigate("/login");
  }, [isAuthenticated, isLoading, navigate]);

  if (isLoading)
    return (
      &lt;FullPage&gt;
        &lt;Spinner /&gt;
      &lt;/FullPage&gt;
    );

  if (isAuthenticated) return children;

  return null; // navigation will happen via effect
}

export default ProtectedRoute;</code></pre>

      <div class="callout">
        <p><strong>‚ö†Ô∏è Important detail</strong></p>
        <p>
          We must not redirect while <code>isLoading</code> is true, because ‚Äúnot authenticated yet‚Äù during loading
          doesn‚Äôt mean the user is truly logged out.
        </p>
      </div>

      <div class="divider"></div>

      <h2>6) Wrap your App Layout route</h2>
      <p>
        Since all your pages are nested under the App Layout route,
        you wrap the App Layout element with ProtectedRoute.
      </p>

      <pre><code>// Router config (conceptual)
{
  element: (
    &lt;ProtectedRoute&gt;
      &lt;AppLayout /&gt;
    &lt;/ProtectedRoute&gt;
  ),
  children: [
    // dashboard, bookings, cabins, ...
  ],
}</code></pre>

      <div class="divider"></div>

      <h2>7) UX improvement: avoid the ‚Äúspinner flash‚Äù after login</h2>
      <p>
        Right after logging in, you sometimes see a brief spinner flash because:
      </p>
      <ul>
        <li>Login happens</li>
        <li>Then ProtectedRoute runs and calls <code>getCurrentUser()</code> again</li>
      </ul>

      <div class="callout">
        <p><strong>‚úÖ Nice optimization</strong></p>
        <p>
          After a successful login, manually set the user into React Query cache so <code>useUser()</code> can read it instantly.
        </p>
      </div>

      <pre><code>// hooks/useLogin.js (conceptual)
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { login } from "../services/apiAuth";

export function useLogin() {
  const queryClient = useQueryClient();

  const { mutate: loginUser, isLoading } = useMutation({
    mutationFn: login,
    onSuccess: (data) =&gt; {
      // key MUST be an array
      queryClient.setQueryData(["user"], data.user);
    },
  });

  return { loginUser, isLoading };
}</code></pre>

      <div class="callout">
        <p><strong>üß† Key learning</strong></p>
        <p>
          React Query can do more than fetch/invalidate‚Äî<code>setQueryData</code> lets you manually seed the cache.
        </p>
      </div>

      <div class="divider"></div>

      <h2>8) Small UX fix: clear inputs after login errors</h2>
      <p>
        When login fails (wrong credentials), it‚Äôs better UX to clear email/password fields.
        This must be done in the component (not inside the hook), because the hook does not have access to local state setters.
      </p>

      <pre><code>// LoginForm.jsx (conceptual)
const { loginUser } = useLogin();

function handleSubmit(e) {
  e.preventDefault();

  loginUser(
    { email, password },
    {
      onSettled: () =&gt; {
        setEmail("");
        setPassword("");
      },
    }
  );
}</code></pre>

      <div class="callout">
        <p><strong>‚úÖ Why ‚Äúoutside the hook‚Äù</strong></p>
        <ul>
          <li>The hook should stay reusable and not depend on a specific form.</li>
          <li>Form state (email/password) lives in the LoginForm component.</li>
        </ul>
      </div>

      <div class="divider"></div>

      <h2>9) Quick self-check (practice)</h2>
      <ul>
        <li>üß© Why is protecting the App Layout route more scalable than protecting every page route?</li>
        <li>üíæ Why do we call <code>getSession()</code> first, and return <code>null</code> if there is no session?</li>
        <li>üîí Why is fetching the user with <code>supabase.auth.getUser()</code> considered more secure than reading from session?</li>
        <li>‚ö° How does <code>queryClient.setQueryData(["user"], user)</code> reduce the ‚Äúspinner flash‚Äù after login?</li>
        <li>üßº Why is clearing login fields done in the component via mutation options (like <code>onSettled</code>)?</li>
      </ul>

      <p class="small">
        End of reviewer. Next lecture: implement logout functionality.
      </p>
    </main>
  </div>
</body>
</html>

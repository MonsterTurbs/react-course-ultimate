

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>React Query â€” Fetching Cabin Data (Wild Oasis) â€” Study Guide</title>
  <style>
    /* ==============================
       A4 PRINT-FRIENDLY, SINGLE COLUMN
       ============================== */
    :root {
      --bg: #ffffff;
      --text: #111111;
      --muted: #555555;
      --border: #e6e6e6;
      --soft: #fafafa;
      --soft2: #f4f6f8;
      --accent: #0b57d0;
      --accent2: #1a73e8;
      --ok: #0f7b4a;
      --warn: #8a5a00;
      --danger: #b00020;
      --codebg: #f5f5f5;   /* light gray */
      --codefg: #111111; /* optional: make text dark */
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.6;
      overflow-wrap: anywhere;
      word-break: break-word;
      -webkit-print-color-adjust: exact;
      print-color-adjust: exact;
    }

    /* Single-column container */
    .page {
      max-width: 820px;
      margin: 0 auto;
      padding: 28px 22px;
    }

    header {
      border-bottom: 2px solid var(--border);
      padding-bottom: 14px;
      margin-bottom: 18px;
    }

    h1 {
      font-size: 24px;
      margin: 0 0 6px 0;
      letter-spacing: 0.2px;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 13.5px;
    }

    .meta {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      display: inline-block;
      border: 1px solid var(--border);
      background: var(--soft);
      padding: 5px 10px;
      border-radius: 999px;
      font-size: 12.5px;
      color: var(--muted);
    }

    h2 {
      font-size: 18px;
      margin: 22px 0 10px;
    }

    h3 {
      font-size: 15px;
      margin: 16px 0 8px;
    }

    p { margin: 10px 0; }

    ul { margin: 8px 0 10px 22px; }
    li { margin: 6px 0; }

    .callout {
      border: 1px solid var(--border);
      background: var(--soft);
      border-left: 6px solid var(--accent);
      border-radius: 10px;
      padding: 12px 14px;
      margin: 12px 0;
    }

    .callout.ok { border-left-color: var(--ok); }
    .callout.warn { border-left-color: var(--warn); }
    .callout.danger { border-left-color: var(--danger); }

    .callout .title {
      font-weight: 700;
      margin: 0 0 6px 0;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin: 10px 0;
    }

    .card {
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 10px;
      padding: 12px 14px;
    }

    .card h4 {
      margin: 0 0 6px 0;
      font-size: 14px;
    }

    .muted { color: var(--muted); }

    pre {
      margin: 10px 0;
      padding: 12px 12px;
      border-radius: 10px;
      background: var(--codebg);
      color: var(--codefg);
      overflow: auto;
      border: 1px solid rgba(255,255,255,0.12);
    }

    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
    }

    .inline-code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
      background: var(--soft2);
      border: 1px solid var(--border);
      padding: 2px 6px;
      border-radius: 6px;
      white-space: nowrap;
    }

    .divider {
      height: 1px;
      background: var(--border);
      margin: 18px 0;
    }

    .checklist li {
      list-style: none;
      margin-left: -22px;
      padding-left: 0;
    }

    .checklist li::before {
      content: "â˜ ";
      color: var(--muted);
      font-weight: 700;
    }

    .kbd {
      display: inline-block;
      border: 1px solid var(--border);
      background: var(--soft);
      padding: 1px 6px;
      border-radius: 6px;
      font-size: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* Print rules */
    @page {
      size: A4;
      margin: 14mm 14mm;
    }

    @media print {
      body { background: #fff; }
      .page { padding: 0; max-width: 100%; }
      a { color: var(--text); text-decoration: none; }
      pre { page-break-inside: avoid; }
      .callout, .card { page-break-inside: avoid; }
      h2, h3 { page-break-after: avoid; }
    }
  </style>
</head>

<body>
  <main class="page">
    <header>
      <h1>ğŸ¨ React Query â€” Fetching Cabin Data (Wild Oasis)</h1>
      <p class="subtitle">Reviewer / Study Guide (Beginner-friendly) â€¢ Single-column â€¢ A4 print-ready</p>
      <div class="meta">
        <span class="chip">âš›ï¸ React</span>
        <span class="chip">ğŸ§  Remote State</span>
        <span class="chip">ğŸ“¦ @tanstack/react-query (v4)</span>
        <span class="chip">ğŸ—„ï¸ Supabase</span>
        <span class="chip">ğŸ§° Devtools</span>
      </div>
    </header>

    <section>
      <h2>ğŸ¯ Goal of this lecture</h2>
      <p>
        Replace manual data fetching (<span class="inline-code">useEffect + fetch</span>) with React Query
        so it can <strong>fetch, cache, and keep cabin data in sync</strong> automatically.
      </p>

      <div class="callout ok">
        <p class="title">âœ… Big idea</p>
        <p>
          With React Query, you donâ€™t â€œstoreâ€ server data in component state manually.
          You describe <strong>what data you want</strong> and <strong>how to fetch it</strong>, and React Query handles:
          caching, loading states, errors, refetching rules, etc.
        </p>
      </div>
    </section>

    <section>
      <h2>ğŸ§© What weâ€™re building</h2>
      <ul>
        <li>ğŸ“„ <strong>Cabins page</strong> becomes a layout of rows (no extra wrapper div).</li>
        <li>ğŸ§± A <strong>CabinTable</strong> component that renders a â€œtable-like UIâ€ using <span class="inline-code">div</span>s + CSS grid.</li>
        <li>ğŸ§¾ One <strong>CabinRow</strong> per cabin record from Supabase.</li>
        <li>â³ A <strong>Spinner</strong> while loading.</li>
      </ul>

      <div class="callout warn">
        <p class="title">âš ï¸ Page component convention</p>
        <p>
          In this project, pages should return content that can be placed <em>directly</em> inside the
          <span class="inline-code">&lt;main&gt;</span> of <span class="inline-code">AppLayout</span>.
          Avoid adding an extra wrapper element if it would interfere with shared layout styling.
        </p>
      </div>
    </section>

    <section>
      <h2>ğŸ”‘ React Query basics: <span class="inline-code">useQuery</span></h2>
      <p>
        The main hook we use is <strong>useQuery</strong>.
        It needs two key ingredients:
      </p>

      <div class="grid">
        <div class="card">
          <h4>1) ğŸ·ï¸ queryKey</h4>
          <p class="muted">Unique identifier for the cached data.</p>
          <ul>
            <li>Must be an <strong>array</strong> (even if it has only 1 item).</li>
            <li>Same key âœ React Query reuses cached data.</li>
          </ul>
          <p><span class="inline-code">queryKey: ["cabins"]</span></p>
        </div>

        <div class="card">
          <h4>2) ğŸ§² queryFn</h4>
          <p class="muted">Function that fetches the data (must return a Promise).</p>
          <ul>
            <li>Usually calls your API service function (e.g., <span class="inline-code">getCabins</span>).</li>
            <li>React Query calls this automatically when needed.</li>
          </ul>
          <p><span class="inline-code">queryFn: getCabins</span></p>
        </div>
      </div>

      <div class="callout">
        <p class="title">ğŸ’¡ Why must queryFn return a Promise?</p>
        <p>
          React Query is designed for async server data. It needs a Promise so it can track:
          loading, success, error, retries, caching, and refetching.
        </p>
      </div>
    </section>

    <section>
      <h2>ğŸ§ª Example: fetching cabins in <span class="inline-code">CabinTable</span></h2>
      <p>
        You already have a service function like <span class="inline-code">getCabins</span> (async) that returns the data.
        Now React Query will call it.
      </p>

      <pre><code>// CabinTable.jsx (conceptual example)
import { useQuery } from "@tanstack/react-query";
import Spinner from "../ui/Spinner";
import { getCabins } from "../services/apiCabins";

function CabinTable() {
  const {
    isLoading,
    data: cabins,
    error,
  } = useQuery({
    queryKey: ["cabins"],
    queryFn: getCabins,
  });

  if (isLoading) return &lt;Spinner /&gt;;
  if (error) return &lt;p&gt;âŒ Cabins could not be loaded.&lt;/p&gt;;

  return (
    &lt;div role="table"&gt;
      {/* header + rows */}
    &lt;/div&gt;
  );
}

export default CabinTable;</code></pre>

      <div class="callout ok">
        <p class="title">âœ… What you get â€œfor freeâ€</p>
        <ul>
          <li>â³ <strong>isLoading</strong> state automatically</li>
          <li>âŒ <strong>error</strong> state automatically</li>
          <li>ğŸ§  <strong>cache</strong> so navigating away/back doesnâ€™t refetch immediately</li>
        </ul>
      </div>
    </section>

    <section>
      <h2>ğŸ§± Rendering the â€œtableâ€ (div-based grid)</h2>
      <p>
        Instead of HTML <span class="inline-code">&lt;table&gt;</span>, the UI uses <span class="inline-code">div</span>s + CSS grid.
        To keep it accessible, you can add ARIA roles.
      </p>

      <pre><code>// Table skeleton idea
&lt;Table role="table"&gt;
  &lt;TableHeader role="row"&gt;
    &lt;div&gt;&lt;/div&gt; {/* image */}
    &lt;div&gt;Cabin&lt;/div&gt;
    &lt;div&gt;Capacity&lt;/div&gt;
    &lt;div&gt;Price&lt;/div&gt;
    &lt;div&gt;Discount&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt; {/* actions */}
  &lt;/TableHeader&gt;

  {cabins.map(cabin =&gt; (
    &lt;CabinRow cabin={cabin} key={cabin.id} /&gt;
  ))}
&lt;/Table&gt;</code></pre>

      <div class="callout">
        <p class="title">â™¿ Accessibility note</p>
        <p>
          If you donâ€™t use a real <span class="inline-code">&lt;table&gt;</span>, adding roles like
          <span class="inline-code">role="table"</span> and <span class="inline-code">role="row"</span>
          helps screen readers interpret structure.
        </p>
      </div>
    </section>

    <section>
      <h2>ğŸ§¾ CabinRow: render one cabin</h2>
      <p>
        You can destructure properties from the cabin object to keep JSX clean.
        Example fields: <span class="inline-code">name</span>, <span class="inline-code">maxCapacity</span>,
        <span class="inline-code">regularPrice</span>, <span class="inline-code">discount</span>, <span class="inline-code">image</span>.
      </p>

      <pre><code>// CabinRow.jsx (conceptual example)
import { formatCurrency } from "../utils/helpers";

function CabinRow({ cabin }) {
  const { name, maxCapacity, regularPrice, discount, image } = cabin;

  return (
    &lt;TableRow role="row"&gt;
      &lt;img src={image} alt={`Cabin ${name}`} /&gt;
      &lt;Cabin&gt;{name}&lt;/Cabin&gt;
      &lt;div&gt;Fits up to {maxCapacity} guests&lt;/div&gt;
      &lt;Price&gt;{formatCurrency(regularPrice)}&lt;/Price&gt;
      &lt;Discount&gt;{formatCurrency(discount)}&lt;/Discount&gt;
      &lt;button&gt;Delete&lt;/button&gt;
    &lt;/TableRow&gt;
  );
}

export default CabinRow;</code></pre>

      <div class="callout warn">
        <p class="title">ğŸ“¦ Dependency reminder</p>
        <p>
          If your helpers use date utilities, install:
          <span class="inline-code">npm i date-fns</span>
        </p>
      </div>
    </section>

    <section>
      <h2>ğŸ§° Using React Query Devtools</h2>
      <p>
        The devtools help you see what is in the cache.
        Once cabins are fetched, youâ€™ll see an entry with the same key:
        <span class="inline-code">["cabins"]</span>.
      </p>

      <div class="callout">
        <p class="title">ğŸ” What to look for</p>
        <ul>
          <li>âœ… Query key (e.g., cabins)</li>
          <li>ğŸ“¦ Cached data array</li>
          <li>ğŸŸ¢ Fresh vs ğŸŸ¡ Stale status</li>
          <li>ğŸ”„ Fetching indicators</li>
        </ul>
      </div>
    </section>

    <section>
      <h2>ğŸ§  The â€œmagicâ€: caching &amp; instant navigation</h2>
      <p>
        The key behavior demonstrated in the lecture is:
      </p>
      <ul>
        <li>When you first visit the cabins page, data is fetched and cached. â³â¡ï¸âœ…</li>
        <li>If you navigate away (component unmounts), the query becomes <em>inactive</em> but stays cached. ğŸ§Š</li>
        <li>When you navigate back, React Query serves cached data instantly (often no spinner). âš¡</li>
      </ul>

      <div class="callout ok">
        <p class="title">âœ… Compare with useEffect</p>
        <p>
          A typical <span class="inline-code">useEffect</span> approach refetches whenever the component remounts.
          React Query avoids unnecessary refetching by default because it can reuse cached data.
        </p>
      </div>
    </section>

    <section>
      <h2>â±ï¸ Fresh vs Stale &amp; the <span class="inline-code">staleTime</span> option</h2>
      <p>
        React Query marks cached data as:
      </p>
      <ul>
        <li><strong>Fresh</strong> ğŸŸ¢ â€” considered valid; React Query wonâ€™t refetch in many situations.</li>
        <li><strong>Stale</strong> ğŸŸ¡ â€” considered old; certain triggers will refetch to resync.</li>
      </ul>

      <div class="callout">
        <p class="title">ğŸ“Œ staleTime meaning</p>
        <p>
          <strong>staleTime</strong> is how long data stays â€œfreshâ€ after it was fetched.
          After that time passes, it becomes â€œstale.â€
        </p>
      </div>

      <pre><code>// App.jsx (conceptual example)
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60 * 1000, // 1 minute
    },
  },
});</code></pre>

      <div class="callout warn">
        <p class="title">ğŸ§ª Lecture experiment: staleTime = 0</p>
        <p>
          Setting <span class="inline-code">staleTime: 0</span> makes data become stale immediately.
          This increases refetching on common triggers (e.g., tab focus) and can be useful while testing.
        </p>
      </div>
    </section>

    <section>
      <h2>ğŸ”„ Automatic refetch trigger example (tab focus)</h2>
      <p>
        Demo scenario:
      </p>
      <ol>
        <li>Open cabins page, data is loaded and cached.</li>
        <li>Wait until data becomes stale (based on <span class="inline-code">staleTime</span>).</li>
        <li>Switch to another tab (simulate leaving the app).</li>
        <li>Update a cabin in Supabase (simulate another user updating data).</li>
        <li>Return to the app tab âœ React Query refetches (if data is stale) and UI updates. âœ…</li>
      </ol>

      <div class="callout ok">
        <p class="title">âœ… What problem does this solve?</p>
        <p>
          It keeps multiple users/browsers in sync with server data.
          If remote data changes elsewhere, your app can refresh without manual wiring.
        </p>
      </div>
    </section>

    <section>
      <h2>ğŸ“ Quick checklist (for your project)</h2>
      <ul class="checklist">
        <li>Use <span class="inline-code">useQuery</span> with <span class="inline-code">queryKey</span> and <span class="inline-code">queryFn</span>.</li>
        <li>Return a <span class="inline-code">&lt;Spinner /&gt;</span> while <span class="inline-code">isLoading</span> is true.</li>
        <li>Render table header + map rows from <span class="inline-code">cabins</span>.</li>
        <li>Use Devtools to inspect cached data and query status.</li>
        <li>Understand Fresh ğŸŸ¢ vs Stale ğŸŸ¡ and how <span class="inline-code">staleTime</span> affects refetching.</li>
        <li>Install <span class="inline-code">date-fns</span> if helpers depend on it.</li>
      </ul>
    </section>

    <div class="divider"></div>

    <section>
      <h2>â¡ï¸ Whatâ€™s next</h2>
      <p>
        Next lecture focuses on <strong>mutations</strong> (changing server data):
        creating, updating, and deleting data in Supabase â€” and letting React Query keep the UI updated.
      </p>

      <div class="callout">
        <p class="title">ğŸ’¬ Memory tip</p>
        <p>
          Think of React Query as a â€œserver-state manager.â€
          UI state stays in React; server state lives in React Queryâ€™s cache.
        </p>
      </div>
    </section>
  </main>
</body>
</html>
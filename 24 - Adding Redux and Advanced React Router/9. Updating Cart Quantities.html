

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Updating Cart Quantities ‚Äî Reusable +/- Component + Reducer Guard (Study Guide)</title>
  <style>
    :root {
      --bg: #ffffff;
      --text: #111111;
      --muted: #555555;
      --border: #e6e6e6;
      --soft: #fafafa;
      --codebg: #f7f7f9;
      --warn: #8a4b00;
      --ok: #0b7a2a;
    }

    * { box-sizing: border-box; }

    html, body { height: 100%; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.55;
      overflow-wrap: anywhere;
      word-break: normal;
    }

    /* Single-column layout */
    .page {
      max-width: 900px;
      margin: 0 auto;
      padding: 28px 18px 36px;
    }

    header {
      border: 1px solid var(--border);
      background: var(--soft);
      padding: 18px 16px;
      border-radius: 10px;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 1.55rem;
      letter-spacing: 0.1px;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 0.98rem;
    }

    .meta {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      border: 1px solid var(--border);
      background: #fff;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.9rem;
      color: var(--muted);
      white-space: nowrap;
    }

    main { margin-top: 18px; }

    section {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      margin: 14px 0;
      background: #fff;
    }

    h2 {
      margin: 0 0 10px;
      font-size: 1.2rem;
    }

    h3 {
      margin: 14px 0 8px;
      font-size: 1.05rem;
    }

    p { margin: 8px 0; }

    ul, ol {
      margin: 8px 0 0 22px;
      padding: 0;
    }

    li { margin: 6px 0; }

    .callout {
      border-left: 4px solid var(--border);
      background: var(--soft);
      padding: 10px 12px;
      border-radius: 8px;
      margin: 10px 0;
    }

    .callout strong { color: var(--text); }

    .callout.warn { border-left-color: var(--warn); }
    .callout.ok { border-left-color: var(--ok); }

    code, pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    pre {
      margin: 10px 0;
      padding: 12px;
      background: var(--codebg);
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: auto;
      white-space: pre;
      tab-size: 2;
    }

    .divider {
      height: 1px;
      background: var(--border);
      margin: 12px 0;
    }

    .two-col {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    @media (min-width: 860px) {
      .two-col {
        grid-template-columns: 1fr 1fr;
      }
    }

    /* Print rules */
    @page {
      size: A4;
      margin: 18mm;
    }

    @media print {
      body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
      .page { max-width: none; padding: 0; }
      header, section { break-inside: avoid; page-break-inside: avoid; }
      a { color: inherit; text-decoration: none; }
      pre { overflow: visible; white-space: pre-wrap; word-break: break-word; }
      .chip { border-color: #dcdcdc; }
    }
  </style>
</head>

<body>
  <div class="page">
    <header>
      <h1>‚ûï‚ûñ Updating Cart Quantities (Redux)</h1>
      <p class="subtitle">Study guide from the lecture transcript: build a reusable <code>UpdateItemQuantity</code> component, add +/- round buttons, prevent negative quantities, and reuse logic by calling another reducer.</p>
      <div class="meta">
        <span class="chip">‚ôªÔ∏è Reusable component: <code>UpdateItemQuantity</code></span>
        <span class="chip">üß© Hooks: <code>useDispatch</code>, <code>useSelector</code></span>
        <span class="chip">‚¨áÔ∏è‚¨ÜÔ∏è Actions: <code>decreaseItemQuantity</code>, <code>increaseItemQuantity</code></span>
        <span class="chip">üîé Selector: <code>getCurrentQuantityById</code></span>
        <span class="chip">üß† Trick: call another reducer via <code>cartSlice.caseReducers</code></span>
      </div>
    </header>

    <main>
      <section>
        <h2>üéØ Goal of this lesson</h2>
        <p>
          You will update the cart logic so users can:
        </p>
        <ul>
          <li>‚ûï Increase quantity of a pizza</li>
          <li>‚ûñ Decrease quantity of a pizza</li>
          <li>üßπ Automatically remove an item when its quantity reaches 0</li>
        </ul>
        <p>
          And you will support this in two places:
        </p>
        <ul>
          <li>üìã The menu item (so users can adjust quickly while browsing)</li>
          <li>üõí The cart item list (typical shopping cart behavior)</li>
        </ul>
      </section>

      <section>
        <h2>‚ôªÔ∏è Pattern: build a reusable quantity component</h2>
        <p>
          This is very similar to the previous lesson where you built a reusable <code>DeleteItem</code> component.
          Now you create:
          <strong><code>UpdateItemQuantity.jsx</code></strong>
        </p>

        <div class="callout ok">
          <p><strong>‚úÖ Why reusable?</strong></p>
          <ul>
            <li>Same UI/logic works in both Cart and Menu</li>
            <li>Components stay smaller and cleaner</li>
            <li>One place to improve UX later</li>
          </ul>
        </div>
      </section>

      <section>
        <h2>üß± Step-by-step: create <code>UpdateItemQuantity</code></h2>
        <p>
          The component needs two key inputs:
        </p>
        <ul>
          <li>üÜî <strong>pizzaId</strong> (so Redux knows which item to update)</li>
          <li>üî¢ <strong>currentQuantity</strong> (to display the number between the buttons)</li>
        </ul>

        <pre><code>// UpdateItemQuantity.jsx (conceptual)
import { useDispatch } from "react-redux";
import Button from "../ui/Button"; // path may vary
import { decreaseItemQuantity, increaseItemQuantity } from "../cart/cartSlice"; // path may vary

function UpdateItemQuantity({ pizzaId, currentQuantity }) {
  const dispatch = useDispatch();

  return (
    &lt;div className="flex items-center gap-1 sm:gap-2"&gt;
      &lt;Button type="round" onClick={() =&gt; dispatch(decreaseItemQuantity(pizzaId))}&gt;
        ‚àí
      &lt;/Button&gt;

      &lt;span className="text-sm font-medium"&gt;{currentQuantity}&lt;/span&gt;

      &lt;Button type="round" onClick={() =&gt; dispatch(increaseItemQuantity(pizzaId))}&gt;
        +
      &lt;/Button&gt;
    &lt;/div&gt;
  );
}

export default UpdateItemQuantity;
</code></pre>

        <div class="callout">
          <p><strong>üß† Important</strong></p>
          <p>
            Both actions need the <strong>pizzaId</strong> as payload.
            That‚Äôs why the component accepts <code>pizzaId</code> as a prop.
          </p>
        </div>
      </section>

      <section>
        <h2>üîò Adding a new ‚Äúround‚Äù button style</h2>
        <p>
          The lecture extends the existing <code>Button</code> component by introducing a new type:
          <strong><code>type="round"</code></strong>.
        </p>

        <pre><code>// Button.jsx (conceptual)
const styles = {
  small: "...",
  // New style:
  round: "px-2.5 py-1 text-sm rounded-full ...",
};
</code></pre>

        <div class="callout">
          <p><strong>Tip</strong></p>
          <p>
            The exact Tailwind classes may differ, but the idea is: small, circular-ish buttons for +/-.
          </p>
        </div>
      </section>

      <section>
        <h2>‚úÖ Testing: quantities and totals update automatically</h2>
        <p>
          Once the onClick handlers dispatch the actions correctly, you will see:
        </p>
        <ul>
          <li>‚ûï Quantity goes up</li>
          <li>üí∞ Total price increases</li>
          <li>üßæ Cart overview values update too</li>
        </ul>
      </section>

      <section>
        <h2>üö´ Bug: decreasing below zero (and how to fix it properly)</h2>
        <p>
          If you keep decreasing when quantity is already 1, you can go to 0 and even to negative numbers.
          That should never happen.
        </p>

        <div class="callout warn">
          <p><strong>‚ùå Wrong UX</strong></p>
          <ul>
            <li>Quantity becomes 0 or -1</li>
            <li>Total price becomes weird/incorrect</li>
          </ul>
        </div>

        <p>
          The lecture fixes this inside the reducer:
          when quantity becomes <strong>0</strong>, remove the item completely.
        </p>
      </section>

      <section>
        <h2>üß† Nice trick: reuse delete logic by calling another reducer</h2>
        <p>
          Instead of duplicating the ‚Äúremove item from cart‚Äù logic, you can reuse it.
          Redux Toolkit exposes reducers on:
          <code>cartSlice.caseReducers</code>.
        </p>

        <pre><code>// cartSlice.js (conceptual)
const cartSlice = createSlice({
  name: "cart",
  initialState,
  reducers: {
    deleteItem(state, action) {
      // removes item by pizzaId
    },

    decreaseItemQuantity(state, action) {
      const id = action.payload;
      const item = state.cart.find((item) =&gt; item.pizzaId === id);

      item.quantity--;
      item.totalPrice = item.quantity * item.unitPrice;

      // ‚úÖ Guard: if it hits 0, remove it
      if (item.quantity === 0)
        cartSlice.caseReducers.deleteItem(state, action);
    },

    increaseItemQuantity(state, action) {
      // increments item.quantity
    },
  },
});
</code></pre>

        <div class="callout ok">
          <p><strong>‚úÖ Why this is elegant</strong></p>
          <ul>
            <li>‚ôªÔ∏è No duplicated delete logic</li>
            <li>üß† Clear: ‚Äúif quantity is 0, delete item‚Äù</li>
            <li>üß™ Easier to test and maintain</li>
          </ul>
        </div>
      </section>

      <section>
        <h2>üîé Displaying current quantity between the buttons</h2>
        <p>
          To display the number, you need <code>currentQuantity</code>.
          In the menu, you don‚Äôt naturally have it, so you derive it from Redux using the selector you created earlier.
        </p>

        <pre><code>// cartSlice.js
export const getCurrentQuantityById = (id) =&gt; (state) =&gt;
  state.cart.cart.find((item) =&gt; item.pizzaId === id)?.quantity ?? 0;
</code></pre>

        <p>Then in a MenuItem:</p>
        <pre><code>// MenuItem.jsx (conceptual)
const currentQuantity = useSelector(getCurrentQuantityById(id));

&lt;UpdateItemQuantity
  pizzaId={id}
  currentQuantity={currentQuantity}
/&gt;
</code></pre>

        <div class="callout">
          <p><strong>üß† Why still pass <code>currentQuantity</code> as a prop?</strong></p>
          <p>
            In the cart item UI you might already have quantity available.
            Passing it in makes the component reusable in both places.
          </p>
        </div>
      </section>

      <section>
        <h2>üõí Reusing in the Cart item UI</h2>
        <p>
          In the cart list, you render both the update component and the delete button.
          Typically you wrap them in a flex container with spacing.
        </p>

        <pre><code>// CartItem.jsx (conceptual)
&lt;div className="flex items-center gap-3 sm:gap-8"&gt;
  &lt;UpdateItemQuantity
    pizzaId={item.pizzaId}
    currentQuantity={item.quantity}
  /&gt;
  &lt;DeleteItem pizzaId={item.pizzaId} /&gt;
&lt;/div&gt;
</code></pre>

        <div class="callout ok">
          <p><strong>‚úÖ Expected behavior</strong></p>
          <ul>
            <li>Decrease from 2 ‚Üí 1: item stays</li>
            <li>Decrease from 1 ‚Üí 0: item disappears (auto-delete)</li>
            <li>Menu toggles back to ‚ÄúAdd to cart‚Äù when item is removed</li>
          </ul>
        </div>
      </section>

      <section>
        <h2>üßØ Common issues and fixes</h2>
        <ul>
          <li>
            ‚ùå <strong>Quantity shows 0 always</strong>
            <div class="callout"><strong>Fix:</strong> Ensure you pass the correct <code>id</code> into <code>getCurrentQuantityById(id)</code> and into <code>pizzaId</code>.</div>
          </li>
          <li>
            ‚ùå <strong>ID vs pizzaId mismatch</strong>
            <div class="callout"><strong>Fix:</strong> In menu it might be <code>pizza.id</code>, in cart it might be <code>item.pizzaId</code>. Confirm in Redux DevTools.</div>
          </li>
          <li>
            ‚ùå <strong>Negative quantities</strong>
            <div class="callout"><strong>Fix:</strong> Add reducer guard: if quantity hits 0, call <code>cartSlice.caseReducers.deleteItem(state, action)</code>.</div>
          </li>
        </ul>
      </section>

      <section>
        <h2>üß™ Mini-quiz (for retention)</h2>
        <ol>
          <li>Why do we create <code>UpdateItemQuantity</code> as a reusable component?</li>
          <li>What payload do the increase/decrease actions need, and why?</li>
          <li>What should happen when quantity goes from 1 to 0?</li>
          <li>What does <code>cartSlice.caseReducers.deleteItem(state, action)</code> help you avoid?</li>
        </ol>
      </section>

      <section>
        <h2>üßæ Quick recap</h2>
        <ul>
          <li>‚ûï‚ûñ Build <code>UpdateItemQuantity</code> with round +/- buttons</li>
          <li>üß© Dispatch <code>increaseItemQuantity(pizzaId)</code> and <code>decreaseItemQuantity(pizzaId)</code></li>
          <li>üö´ Prevent negatives by auto-deleting item at quantity 0</li>
          <li>‚ôªÔ∏è Reuse delete reducer using <code>cartSlice.caseReducers.deleteItem</code></li>
          <li>üî¢ Show current quantity between buttons using <code>getCurrentQuantityById</code></li>
          <li>‚û°Ô∏è Next: submit an order using the cart items in state</li>
        </ul>
      </section>
    </main>
  </div>
</body>
</html>
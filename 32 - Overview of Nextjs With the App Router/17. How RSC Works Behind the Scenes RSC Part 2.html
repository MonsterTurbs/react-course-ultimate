<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Next.js + React Server Components ‚Äî Behind the Scenes (RSC Part 2) | Study Guide</title>
  <style>
    :root{
      --bg:#ffffff;
      --text:#111111;
      --muted:#5a5a5a;
      --border:#e6e6e6;
      --soft:#fafafa;
      --soft2:#f3f4f6;
      --accent:#0b57d0;
      --accent2:#0a7a3d;
      --warn:#b54708;
      --danger:#b42318;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: Arial, Helvetica, sans-serif;
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background: var(--bg);
      line-height:1.6;
      overflow-wrap:anywhere;
      word-break:normal;
    }

    /* Page container: single column, print-friendly width */
    .page{
      max-width: 900px;
      margin: 0 auto;
      padding: 28px 22px 44px;
    }

    header{
      border:1px solid var(--border);
      background: linear-gradient(0deg, var(--soft), #fff);
      padding: 18px 18px 14px;
      border-radius: 14px;
    }

    .kicker{
      font-size: 12px;
      color: var(--muted);
      letter-spacing: .2px;
      text-transform: uppercase;
      margin: 0 0 6px;
    }

    h1{
      font-size: 26px;
      line-height: 1.2;
      margin: 0 0 8px;
    }

    .subtitle{
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }

    .meta{
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size: 12px;
      color: var(--text);
      background: var(--soft2);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 6px 10px;
      white-space: nowrap;
    }

    main{ margin-top: 16px; }

    section{
      border:1px solid var(--border);
      border-radius: 14px;
      padding: 16px 16px 14px;
      margin: 14px 0;
      background: #fff;
    }

    h2{
      font-size: 18px;
      margin: 0 0 10px;
      line-height: 1.25;
    }

    h3{
      font-size: 15px;
      margin: 14px 0 8px;
      line-height: 1.25;
    }

    p{ margin: 8px 0; }

    ul, ol{ margin: 8px 0 8px 22px; padding:0; }
    li{ margin: 6px 0; }

    .callout{
      border:1px solid var(--border);
      background: var(--soft);
      border-radius: 12px;
      padding: 12px 12px;
      margin: 10px 0;
    }
    .callout strong{ display:inline-block; margin-bottom: 4px; }

    .callout.tip{ border-left: 4px solid var(--accent2); }
    .callout.warn{ border-left: 4px solid var(--warn); }
    .callout.danger{ border-left: 4px solid var(--danger); }

    .two-col{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .card{
      border:1px solid var(--border);
      background: #fff;
      border-radius: 12px;
      padding: 12px;
    }

    .kbd{
      font-family: var(--mono);
      font-size: 12px;
      border:1px solid var(--border);
      background: #fff;
      padding: 2px 6px;
      border-radius: 6px;
      white-space: nowrap;
    }

    pre{
      margin: 10px 0;
      padding: 12px;
      border-radius: 12px;
      border:1px solid var(--border);
      background: #f5f5f5;
      color: #111111;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.5;
      overflow:auto;
      white-space: pre;
      tab-size: 2;
    }
    code{
      font-family: var(--mono);
      font-size: 0.95em;
      background: var(--soft2);
      border: 1px solid var(--border);
      padding: 1px 5px;
      border-radius: 6px;
    }

    table{
      width:100%;
      border-collapse: collapse;
      margin: 10px 0;
      font-size: 13px;
    }
    th, td{
      border:1px solid var(--border);
      padding: 8px 8px;
      vertical-align: top;
    }
    th{
      background: var(--soft);
      text-align:left;
    }

    .hr{
      height:1px;
      background: var(--border);
      margin: 12px 0;
    }

    .mini-title{
      font-weight: 700;
      margin: 0 0 6px;
    }

    .icon{ font-weight: 700; }

    footer{
      margin-top: 14px;
      color: var(--muted);
      font-size: 12px;
      text-align: center;
    }

    /* Print */
    @page{ size: A4; margin: 14mm; }
    @media print{
      body{ -webkit-print-color-adjust: exact; print-color-adjust: exact; }
      .page{ max-width: none; padding: 0; }
      header, section{ break-inside: avoid; page-break-inside: avoid; }
      pre{ break-inside: avoid; page-break-inside: avoid; }
      a{ color: inherit; text-decoration: none; }
      /* Avoid printing URLs after links (browser default behavior) */
      a[href]::after{ content: "" !important; }
    }

    /* Slightly wider layouts on larger screens (still single column) */
    @media (min-width: 820px){
      .two-col{ grid-template-columns: 1fr 1fr; }
      .grid{ grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <p class="kicker">Reviewer / Study Guide</p>
      <h1>How React Server Components Work Behind the Scenes (RSC Part 2)</h1>
      <p class="subtitle">
        Goal: build a clear mental model of the <strong>two-step rendering</strong> process in the RSC architecture, and why the <strong>RSC payload</strong> exists.
      </p>
      <div class="meta">
        <span class="chip">üß† Topic: RSC internals</span>
        <span class="chip">üß© Focus: rendering pipeline</span>
        <span class="chip">üöö Key concept: RSC payload</span>
        <span class="chip">‚úÖ Level: beginner-friendly (with precise terms)</span>
      </div>
    </header>

    <main>
      <section>
        <h2>1) Quick recap: rendering in traditional React (no RSC)</h2>
        <p>
          Think of React rendering as a pipeline that transforms <strong>your components</strong> into <strong>DOM elements</strong>.
          The important part for this lecture is the first half: <strong>rendering = calling component functions</strong>.
        </p>

        <div class="callout tip">
          <strong>‚úÖ Core definition</strong><br />
          Rendering in React means: <span class="icon">üìû</span> call each component function ‚Üí it returns a <strong>React element</strong> (a plain JS object).
        </div>

        <div class="grid">
          <div class="card">
            <p class="mini-title">üß± Step-by-step (simplified)</p>
            <ol>
              <li>You write components (A, B, C).</li>
              <li>React composes them into a <strong>component tree</strong> (instances).</li>
              <li>React <strong>renders</strong> the tree (calls component functions).</li>
              <li>Result: a <strong>React element tree</strong> (a.k.a. virtual DOM).</li>
              <li>React <strong>commits</strong> that to the real DOM (creates/updates actual DOM nodes).</li>
            </ol>
          </div>
          <div class="card">
            <p class="mini-title">üìå What is a React element?</p>
            <p>
              A React element is a JavaScript object describing what should appear in the UI.
              It is <strong>data</strong>, not HTML.
            </p>
            <pre><code>// Rough idea (simplified)
const element = {
  type: 'h1',
  props: { children: 'Hello' }
};</code></pre>
          </div>
        </div>

        <div class="callout warn">
          <strong>Note</strong><br />
          We intentionally ignore re-rendering, diffing, and reconciliation details here‚Äîthis lecture focuses on <strong>where</strong> things run (server vs client) and <strong>what data</strong> moves between them.
        </div>
      </section>

      <section>
        <h2>2) RSC rendering: the big idea (server + client, two steps)</h2>
        <p>
          In the React Server Components (RSC) architecture, one component tree can contain both:
          <strong>Server Components (SC)</strong> and <strong>Client Components (CC)</strong>.
          The key twist is that rendering is split across two environments.
        </p>

        <div class="callout tip">
          <strong>üß≠ High-level summary</strong><br />
          RSC rendering happens in <strong>two steps</strong>:
          <ol>
            <li><strong>Server:</strong> render Server Components (Client Components become placeholders).</li>
            <li><strong>Client:</strong> render Client Components using the info from the payload.</li>
          </ol>
        </div>

        <h3>2.1 Step 1 ‚Äî Server renders only Server Components</h3>
        <p>
          When React runs on the server and encounters a mixed tree (SC + CC), it executes the Server Components.
          Just like traditional React, executing a component returns a <strong>React element</strong>.
        </p>

        <div class="callout">
          <strong>üí° ‚ÄúDisappearing code‚Äù</strong><br />
          After a Server Component is rendered, the output is represented as <strong>data</strong> (React elements). The actual component code is not shipped to the browser.
          That is why Server Components can use ‚Äúbig‚Äù server-only libraries without increasing client bundle size.
        </div>

        <h3>2.2 What happens to Client Components on the server?</h3>
        <p>
          Client Components are <em>not executed</em> on the server during Step 1.
          Instead, React produces placeholders (‚Äúholes‚Äù) where those client components will be rendered later.
        </p>

        <div class="grid">
          <div class="card">
            <p class="mini-title">üï≥Ô∏è Placeholder contains:</p>
            <ul>
              <li><strong>Serialized props</strong> passed from server ‚Üí client</li>
              <li>A <strong>reference to the client bundle/module</strong> (e.g., URL to script containing the CC code)</li>
            </ul>
            <p class="mini-title">Why props must be serializable</p>
            <p>
              Because the payload must travel to the browser. Functions/classes are not serializable.
              That is why you cannot pass functions from a Server Component to a Client Component as props.
            </p>
          </div>
          <div class="card">
            <p class="mini-title">üß† Why Server Components cannot have state</p>
            <ul>
              <li>Hooks like <code>useState</code>/<code>useEffect</code> are functions.</li>
              <li>Server output becomes serialized data; those functions cannot be shipped.</li>
              <li>No persistent client-side ‚Äúhook state‚Äù can be kept on the server for interactivity.</li>
            </ul>
            <div class="callout warn">
              <strong>Important</strong><br />
              Server Components can render UI from data, but they cannot handle client interactivity.
            </div>
          </div>
        </div>

        <h3>2.3 Output of Step 1 ‚Äî the ‚ÄúRSC payload‚Äù</h3>
        <p>
          After Step 1, we end up with a mixed structure:
        </p>
        <ul>
          <li>‚úÖ Rendered Server Components (as React elements / serialized description)</li>
          <li>üï≥Ô∏è Placeholders for Client Component subtrees (with props + code reference)</li>
        </ul>
        <p>
          This mixed structure is called the <strong>RSC payload</strong> ‚Äî it is what gets sent (often streamed) from server to client.
        </p>

        <div class="callout tip">
          <strong>üì¶ Think of the payload as</strong><br />
          ‚ÄúVirtual DOM for server-rendered parts‚Äù + ‚Äúinstructions to render client parts later‚Äù.
        </div>
      </section>

      <section>
        <h2>3) Step 2 ‚Äî Client finishes rendering (Client Components)</h2>
        <p>
          Once the browser receives the RSC payload, React on the client uses it to render the missing Client Components.
          That produces the remaining React elements, completing the virtual DOM.
        </p>

        <div class="callout">
          <strong>üß© After Step 2</strong><br />
          React now has the full virtual DOM and can commit updates to the real DOM using the normal mechanism.
        </div>

        <h3>3.1 Minimal mental model</h3>
        <pre><code>// Server step (conceptually)
RSC_payload = renderServerComponents(tree)
// includes placeholders for client components

// Client step (conceptually)
virtualDOM = fillPlaceholdersByRenderingClientComponents(RSC_payload)
commitToDOM(virtualDOM)</code></pre>

        <div class="callout warn">
          <strong>Terminology warning</strong><br />
          In RSC discussions you may see ‚ÄúReact server‚Äù and ‚ÄúReact client‚Äù.
          This does not always mean a traditional web server + browser page in the simplest sense; it refers to React‚Äôs execution environments.
        </div>
      </section>

      <section>
        <h2>4) Why not just send HTML from server to browser?</h2>
        <p>
          A natural question is: why do we need this payload format at all?
          Why not render Server Components to HTML and ship that directly?
        </p>

        <div class="callout tip">
          <strong>‚úÖ React‚Äôs core philosophy</strong><br />
          React prefers to represent UI as <strong>data</strong> (React elements/trees), not as finished HTML.
        </div>

        <h3>4.1 The critical reason: preserving UI state across updates</h3>
        <p>
          Server Components can re-render (for example, when navigation changes routes).
          When that happens, a new payload is generated and sent.
          React can then <strong>reconcile</strong> the new tree with the existing client tree.
        </p>

        <div class="callout danger">
          <strong>What would go wrong with ‚ÄúHTML only‚Äù?</strong><br />
          If you replaced the whole UI with a fresh chunk of HTML on each server update, you could lose client-side UI state
          (e.g., input values, open menus, local UI toggles) and cause jarring user experience.
        </div>

        <p>
          With the payload approach, React merges server updates into the client-side tree and can keep interactive state where appropriate.
        </p>
      </section>

      <section>
        <h2>5) Traditional React vs RSC ‚Äî side-by-side comparison</h2>

        <table>
          <thead>
            <tr>
              <th style="width:50%">Traditional React</th>
              <th style="width:50%">React + RSC</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                <ul>
                  <li>Render component tree ‚Üí virtual DOM</li>
                  <li>Commit virtual DOM ‚Üí real DOM</li>
                </ul>
              </td>
              <td>
                <ul>
                  <li><strong>Step 1 (server):</strong> render Server Components</li>
                  <li>Create <strong>RSC payload</strong> (server elements + client placeholders)</li>
                  <li><strong>Step 2 (client):</strong> render Client Components</li>
                  <li>Commit final virtual DOM ‚Üí real DOM</li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>
                <strong>Single environment</strong> (the browser)
              </td>
              <td>
                <strong>Two environments</strong> (server + client) with a payload bridging them
              </td>
            </tr>
            <tr>
              <td>
                UI updates typically driven by state and effects
              </td>
              <td>
                Some UI generated from server data (SC), some from client state (CC)
              </td>
            </tr>
          </tbody>
        </table>

        <div class="callout tip">
          <strong>Bottom line</strong><br />
          RSC is not a totally different ‚Äúmystery‚Äù. It is the same idea (component tree ‚Üí element tree), but split across server/client with a structured payload.
        </div>
      </section>

      <section>
        <h2>6) Two final observations</h2>

        <div class="two-col">
          <div class="card">
            <p class="mini-title">üåä 6.1 Streaming makes it feel fast</p>
            <p>
              In practice, Step 1 and Step 2 are not strictly ‚Äúblock until finished‚Äù.
              Completed work can be <strong>streamed</strong> from server to client and integrated as it arrives.
            </p>
            <ul>
              <li>Earlier content can appear sooner</li>
              <li>Better perceived performance</li>
              <li>Pairs naturally with suspense/loading patterns</li>
            </ul>
          </div>
          <div class="card">
            <p class="mini-title">ü§ì 6.2 ‚ÄúUI is a function of data and state‚Äù (more precise)</p>
            <p>
              If you want to be extra accurate:
            </p>
            <ul>
              <li>First: UI is produced from <strong>data</strong> (server step)</li>
              <li>Then: UI becomes interactive via <strong>state</strong> (client step)</li>
            </ul>
            <p class="callout">
              In a two-step pipeline, it is more like: <strong>data ‚Üí initial UI</strong>, then <strong>state ‚Üí interactivity/updates</strong>.
            </p>
          </div>
        </div>
      </section>

      <section>
        <h2>7) Quick self-check (mini quiz) ‚úÖ</h2>
        <ol>
          <li>In RSC Step 1, which components are executed on the server?</li>
          <li>What two things must be included for each Client Component placeholder?</li>
          <li>Why can‚Äôt you pass a function prop from Server ‚Üí Client Component?</li>
          <li>Why does sending HTML-only updates risk losing UI state?</li>
          <li>What is the purpose of the RSC payload in one sentence?</li>
        </ol>

        <div class="callout tip">
          <strong>Answer key (short)</strong><br />
          1) Server Components. 2) Serialized props + reference to client code. 3) Not serializable. 4) Full replacement loses state. 5) It bridges server-rendered UI data and client-rendered interactivity.
        </div>
      </section>

      <footer>
        Printed reviewer ‚Äî single column, A4-optimized.
      </footer>
    </main>
  </div>
</body>
</html>

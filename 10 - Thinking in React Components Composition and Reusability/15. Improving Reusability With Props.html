<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Improving Reusability With Props ‚Äî Study Guide (Print-Friendly)</title>
  <style>
    :root {
      --bg: #ffffff;
      --ink: #111111;
      --muted: #555555;
      --soft: #f6f7f9;
      --border: #e6e6e6;
      --accent: #0b57d0;
      --good: #0f766e;
      --warn: #b45309;
      --bad: #b91c1c;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.6;
      overflow-wrap: anywhere;
      word-break: break-word;
      hyphens: auto;
    }

    /* Single-column page container */
    .page {
      max-width: 820px;
      margin: 0 auto;
      padding: 28px 22px 56px;
    }

    header {
      border: 1px solid var(--border);
      background: #fff;
      padding: 18px 18px 14px;
      border-radius: 12px;
    }

    .kicker {
      color: var(--muted);
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      margin: 0 0 6px;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 22px;
      line-height: 1.25;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }

    main { margin-top: 18px; }

    h2 {
      font-size: 16px;
      margin: 18px 0 8px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
    }

    h3 {
      font-size: 14px;
      margin: 14px 0 6px;
    }

    p { margin: 8px 0; }

    ul, ol {
      margin: 8px 0 8px 20px;
      padding: 0;
    }

    li { margin: 6px 0; }

    .card {
      border: 1px solid var(--border);
      background: var(--soft);
      border-radius: 12px;
      padding: 14px 14px 12px;
      margin: 12px 0;
    }

    .callout {
      border-left: 4px solid var(--accent);
      background: #fff;
      border-radius: 12px;
      padding: 12px 14px;
      margin: 12px 0;
      border: 1px solid var(--border);
    }

    .callout.good { border-left-color: var(--good); }
    .callout.warn { border-left-color: var(--warn); }
    .callout.bad  { border-left-color: var(--bad); }

    .tag {
      display: inline-block;
      font-size: 12px;
      padding: 2px 8px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: #fff;
      color: var(--muted);
      margin-right: 6px;
      white-space: nowrap;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    code, pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
    }

    pre {
      margin: 10px 0;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #ffffff;
      white-space: pre-wrap;
      word-break: break-word;
      overflow: hidden;
    }

    .mini {
      color: var(--muted);
      font-size: 12px;
    }

    .hr {
      height: 1px;
      background: var(--border);
      margin: 14px 0;
    }

    /* Print styles */
    @page {
      size: A4;
      margin: 14mm 14mm 16mm;
    }

    @media print {
      :root { --soft: #ffffff; }
      body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
      .page { max-width: none; padding: 0; }
      header, .card, .callout, pre {
        box-shadow: none !important;
      }
      a, a:visited { color: var(--ink); text-decoration: none; }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <p class="kicker">React ‚Äî Thinking in Components ‚Ä¢ Composition & Reusability</p>
      <h1>Improving Reusability With Props</h1>
      <p class="subtitle">Reviewer / study guide: making a <strong>StarRating</strong> component flexible by designing a good props API (public interface). Includes beginner-friendly notes + examples.</p>
    </header>

    <main>
      <section class="card">
        <span class="tag">üéØ Goal</span>
        <span class="tag">üß© Reusability</span>
        <span class="tag">üß† Props as API</span>
        <p>
          The main idea: if you want a component to be reusable in many apps (even publishable to NPM), it should not be ‚Äúhard-coded‚Äù to one look/behavior.
          Instead, you expose a <strong>public API</strong> using <strong>props</strong> so consumers can configure the component.
        </p>
      </section>

      <section>
        <h2>1) Why the component is not reusable yet</h2>
        <ul>
          <li>üß± It has a fixed appearance (colors, sizes) and fixed behavior (what text shows, how ratings are displayed).</li>
          <li>üë• Different apps have different UI themes (brand colors, spacing, typography).</li>
          <li>üì¶ If you publish the component, unknown consumers will need configuration knobs.</li>
        </ul>

        <div class="callout warn">
          <p><strong>‚öñÔ∏è Key principle:</strong> Avoid ‚Äútoo few props‚Äù (component is useless) and also avoid ‚Äútoo many props‚Äù (component becomes complex and hard to use).</p>
        </div>
      </section>

      <section>
        <h2>2) Add styling props: <code>color</code> and <code>size</code></h2>
        <p>
          Start with small, high-impact styling controls:
          <strong>star color</strong> and <strong>star size</strong>.
          Provide defaults so the component works even if the consumer passes nothing.
        </p>

        <h3>‚úÖ Default values via destructuring</h3>
        <pre><code>// Good: defaults keep the component usable out-of-the-box
export default function StarRating({
  maxRating = 5,
  color = "#fcc419",
  size = 48,
}) {
  // ...
}
</code></pre>

        <h3>üîß Use props to set styles</h3>
        <ul>
          <li>üü° Text color: <code>style={{ color }}</code></li>
          <li>üî† Text size: derived from star size (e.g., <code>size / 1.5</code>)</li>
          <li>‚≠ê Star SVG stroke/fill: set to <code>color</code></li>
          <li>üìè Star width/height: set to <code>size</code> in pixels</li>
        </ul>

        <div class="callout good">
          <p><strong>Tip:</strong> If a style object depends on props, it must live <em>inside</em> the component (because props exist only there).</p>
        </div>

        <h3>Example usage (consumer side)</h3>
        <pre><code>&lt;StarRating maxRating={5} /&gt;
&lt;StarRating maxRating={10} size={24} color="red" /&gt;
</code></pre>
      </section>

      <section>
        <h2>3) Allow custom styling hook: <code>className</code></h2>
        <p>
          Some consumers want to style via their own CSS instead of inline styles.
          A common pattern is accepting <code>className</code> and attaching it to your root element.
        </p>

        <pre><code>export default function StarRating({ className = "", ...props }) {
  return (
    &lt;div className={className}&gt;
      {/* component UI */}
    &lt;/div&gt;
  );
}
</code></pre>

        <div class="callout">
          <p><strong>üß© Why this helps:</strong> Consumers can change font family, spacing, etc., in their own stylesheet without you adding many new props.</p>
        </div>
      </section>

      <section>
        <h2>4) Improve UX with <code>messages</code> array</h2>
        <p>
          Instead of showing a number (e.g., ‚Äú4‚Äù), some apps want text labels (e.g., ‚Äúgood‚Äù, ‚Äúamazing‚Äù).
          You can accept a <code>messages</code> array, where each index maps to a star count.
        </p>

        <h3>Example consumer usage</h3>
        <pre><code>&lt;StarRating
  maxRating={5}
  messages={["terrible", "bad", "okay", "good", "amazing"]}
/&gt;
</code></pre>

        <h3>Safe rendering rule</h3>
        <ul>
          <li>‚úÖ Only use messages if <code>messages.length === maxRating</code></li>
          <li>‚úÖ Otherwise fall back to displaying the number</li>
          <li>üß† Remember: rating is 1-based, array is 0-based ‚áí use <code>rating - 1</code></li>
        </ul>

        <pre><code>// inside render
const label =
  messages.length === maxRating
    ? messages[(tempRating ? tempRating : rating) - 1]
    : (tempRating || rating || "");
</code></pre>

        <div class="callout warn">
          <p><strong>Edge case:</strong> If <code>rating</code> is 0 and <code>tempRating</code> is 0, show an empty string so the UI looks clean.</p>
        </div>
      </section>

      <section>
        <h2>5) Default selection: <code>defaultRating</code></h2>
        <p>
          Sometimes the consumer wants the component to start with a pre-selected rating (seed value).
          This is common for ‚Äúedit mode‚Äù UIs.
        </p>

        <pre><code>export default function StarRating({ defaultRating = 0, ...props }) {
  const [rating, setRating] = useState(defaultRating);
  // ...
}
</code></pre>

        <div class="callout good">
          <p><strong>‚úÖ Important clarification:</strong> Initializing state from props is fine when the prop is only <em>seed data</em> (initial state). It‚Äôs a problem only when you expect state to stay synced with prop changes.</p>
        </div>
      </section>

      <section>
        <h2>6) The ‚Äúmissing‚Äù feature: send rating back to the parent</h2>
        <p>
          If the rating is only stored inside <code>StarRating</code>, the parent cannot use it.
          Example: the parent wants to display <em>‚ÄúThis movie was rated X stars.‚Äù</em>
        </p>

        <div class="callout">
          <p><strong>üì§ Solution:</strong> Accept a callback prop like <code>onSetRating</code> and call it whenever the internal rating changes.</p>
        </div>

        <h3>Parent (consumer) example</h3>
        <pre><code>function Test() {
  const [movieRating, setMovieRating] = useState(0);

  return (
    &lt;&gt;
      &lt;StarRating
        maxRating={10}
        color="blue"
        onSetRating={setMovieRating}
      /&gt;
      &lt;p&gt;This movie was rated {movieRating} stars.&lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre>

        <h3>Inside StarRating</h3>
        <pre><code>function handleRating(newRating) {
  setRating(newRating);
  onSetRating?.(newRating); // optional chaining avoids errors if prop not passed
}
</code></pre>

        <div class="callout warn">
          <p><strong>Why this matters:</strong> Without this callback, the component is mostly presentational from the parent‚Äôs point of view. With it, it becomes truly reusable for real app workflows.</p>
        </div>
      </section>

      <section>
        <h2>7) Quick ‚ÄúAPI checklist‚Äù for this component</h2>
        <div class="grid">
          <div class="card">
            <p><strong>Core behavior</strong> ‚≠ê</p>
            <ul>
              <li><code>maxRating</code> (default: 5)</li>
              <li><code>defaultRating</code> (default: 0)</li>
              <li><code>onSetRating</code> (optional callback)</li>
            </ul>
          </div>
          <div class="card">
            <p><strong>Styling</strong> üé®</p>
            <ul>
              <li><code>color</code> (default: <code>#fcc419</code>)</li>
              <li><code>size</code> (default: 48)</li>
              <li><code>className</code> (default: empty string)</li>
            </ul>
          </div>
          <div class="card">
            <p><strong>UX text</strong> üí¨</p>
            <ul>
              <li><code>messages</code> (default: empty array)</li>
              <li>Uses messages only if <code>messages.length === maxRating</code></li>
            </ul>
          </div>
        </div>
      </section>

      <section>
        <h2>8) Common pitfalls (and how to avoid them)</h2>
        <ul>
          <li>üß® <strong>Too many props:</strong> you expose too much complexity; component becomes hard to use.</li>
          <li>üß© <strong>Too few props:</strong> component cannot fit into different apps/themes.</li>
          <li>üß∑ <strong>Index vs rating confusion:</strong> stars use 0-based index; rating is usually 1-based ‚áí use <code>i + 1</code> and <code>rating - 1</code>.</li>
          <li>üßä <strong>Forgetting defaults:</strong> missing props should not break the component.</li>
          <li>üì§ <strong>Not exposing rating changes:</strong> without <code>onSetRating</code>, parent cannot react to user choice.</li>
        </ul>

        <div class="callout bad">
          <p><strong>Next topic preview:</strong> You still need to prevent invalid prop types (e.g., <code>maxRating="test"</code>). That‚Äôs where <strong>PropTypes</strong> (or TypeScript) becomes useful.</p>
        </div>

        <p class="mini">End of lecture notes: Improving Reusability With Props (StarRating component).</p>
      </section>
    </main>
  </div>
</body>
</html>

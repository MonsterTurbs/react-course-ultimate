

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ultimate React Course â€” React vs Vanilla JavaScript (Reviewer)</title>
  <style>
    :root {
      --bg: #ffffff;
      --text: #111111;
      --muted: #555555;
      --border: #e6e6e6;
      --soft: #fafafa;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.55;
      overflow-wrap: anywhere;
      word-break: break-word;
    }

    /* Single-column container */
    .page {
      max-width: 920px;
      margin: 0 auto;
      padding: 24px 20px 44px;
    }

    header {
      border-bottom: 1px solid var(--border);
      padding-bottom: 14px;
      margin-bottom: 18px;
    }

    h1 {
      font-size: 1.6rem;
      margin: 0 0 6px;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 0.98rem;
    }

    .toolbar {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .btn {
      border: 1px solid var(--border);
      background: var(--soft);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.92rem;
    }

    .btn:active { transform: translateY(1px); }

    section {
      margin: 16px 0;
      padding: 14px 14px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fff;
    }

    h2 {
      margin: 0 0 10px;
      font-size: 1.2rem;
    }

    h3 {
      margin: 14px 0 8px;
      font-size: 1.05rem;
    }

    p { margin: 8px 0; }

    ul, ol {
      margin: 8px 0 0;
      padding-left: 20px;
    }

    li { margin: 6px 0; }

    .muted { color: var(--muted); }

    .callout {
      border-left: 4px solid #d0d0d0;
      background: var(--soft);
      padding: 10px 12px;
      border-radius: 10px;
      margin: 10px 0;
    }

    .toc {
      border: 1px dashed var(--border);
      background: var(--soft);
      border-radius: 12px;
      padding: 12px;
      margin-top: 12px;
    }

    .toc ol {
      margin: 8px 0 0;
      padding-left: 18px;
    }

    .toc a {
      color: inherit;
      text-decoration: none;
      border-bottom: 1px dotted #bdbdbd;
    }

    .toc a:hover { text-decoration: none; }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 10px;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: #fff;
    }

    .pill {
      display: inline-block;
      border: 1px solid var(--border);
      background: var(--soft);
      padding: 2px 10px;
      border-radius: 999px;
      font-size: 0.86rem;
      color: var(--muted);
      white-space: nowrap;
      margin-right: 6px;
    }

    .checklist {
      list-style: none;
      padding-left: 0;
      margin: 8px 0 0;
    }

    .checklist li { margin: 8px 0; }

    pre {
      margin: 10px 0 0;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fcfcfc;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 0.92rem;
      line-height: 1.5;
    }

    code { font-family: Consolas, "Courier New", monospace; }

    /* Keep links readable on screen, but never print URLs */
    a {
      color: inherit;
      text-decoration: none;
      border-bottom: 1px dotted #bdbdbd;
    }

    /* Print styles */
    @page {
      size: A4;
      margin: 12mm;
    }

    @media print {
      body { font-size: 11pt; line-height: 1.45; }
      .page { max-width: none; padding: 0; }
      header { margin-bottom: 10px; padding-bottom: 10px; }
      section { break-inside: avoid; page-break-inside: avoid; }
      .toolbar { display: none !important; }

      /* Donâ€™t print any URL after links */
      a[href]:after { content: "" !important; }

      * { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
    }
  </style>
</head>
<body>
  <main class="page">
    <header>
      <h1>âš›ï¸ React vs ğŸ§± Vanilla JavaScript (Reviewer)</h1>
      <p class="subtitle">Compare the same â€œAdvice Appâ€ built with React vs plain JavaScript, and understand the key mindset shift: state â†’ UI sync. A4 print-ready.</p>
      <div class="toolbar">
        <button class="btn" type="button" onclick="window.print()">ğŸ–¨ï¸ Print / Save as PDF</button>
        <span class="muted">Tip: Single-column, word-wrapped, designed for clean A4 printing (no URLs printed).</span>
      </div>

      <div class="toc">
        <strong>ğŸ“Œ Table of Contents</strong>
        <ol>
          <li><a href="#goal">Goal of this lecture</a></li>
          <li><a href="#two-versions">Two versions of the same app</a></li>
          <li><a href="#philosophy">Philosophy shift: JS-in-charge vs HTML-in-charge</a></li>
          <li><a href="#dom">Manual DOM selection and manipulation</a></li>
          <li><a href="#state">State and UI sync (the core difference)</a></li>
          <li><a href="#scale">Why it matters at scale</a></li>
          <li><a href="#takeaways">Key takeaways</a></li>
          <li><a href="#self-check">Quick self-check</a></li>
        </ol>
      </div>
    </header>

    <section id="goal">
      <h2>ğŸ¯ Goal of this lecture</h2>
      <p>
        You already built a small React â€œAdvice Appâ€ earlier. Now the goal is to compare it with a Vanilla JavaScript
        version to get a â€œfirst feelingâ€ for how React keeps the UI in sync with state.
      </p>

      <div class="callout">
        <p><strong>Main message</strong> âœ…</p>
        <p class="muted">
          In React, you mainly focus on updating <strong>state</strong>. React updates the UI for you.
          In Vanilla JS, you usually update data <em>and</em> manually update the DOM.
        </p>
      </div>
    </section>

    <section id="two-versions">
      <h2>ğŸ§ª Two versions of the same app</h2>
      <p>
        The lecture compares two implementations of the same mini app:
      </p>
      <ul>
        <li>âš›ï¸ <strong>React version</strong>: JSX inside JavaScript, state-driven UI updates</li>
        <li>ğŸ§± <strong>Vanilla JS version</strong>: HTML page + script, manual DOM selection and updates</li>
      </ul>

      <div class="callout">
        <p><strong>Note</strong> ğŸ“</p>
        <p class="muted">
          The Vanilla JS implementation is placed in one HTML file (HTML + JS together) to keep it easy to compare.
        </p>
      </div>
    </section>

    <section id="philosophy">
      <h2>ğŸ” Philosophy shift: JS-in-charge vs HTML-in-charge</h2>
      <div class="grid">
        <div class="card">
          <h3>React (JavaScript is â€œin chargeâ€) âš›ï¸</h3>
          <ul>
            <li>JSX (HTML-like) is written inside JavaScript</li>
            <li>UI is described by components</li>
            <li>UI updates automatically when state changes</li>
          </ul>
        </div>
        <div class="card">
          <h3>Vanilla JS (HTML is â€œin chargeâ€) ğŸ§±</h3>
          <ul>
            <li>You have an HTML file first</li>
            <li>The HTML file loads a script</li>
            <li>You manually select DOM elements and update them</li>
          </ul>
        </div>
      </div>

      <div class="callout">
        <p><strong>Beginner-friendly summary</strong></p>
        <p class="muted">
          React flips the mental model: instead of â€œfind elements and change them,â€ you describe the UI based on data/state.
        </p>
      </div>
    </section>

    <section id="dom">
      <h2>ğŸ§© Manual DOM selection and manipulation</h2>
      <p>
        In Vanilla JS, you typically have to:
      </p>
      <ul>
        <li>ğŸ” Select elements (e.g., advice text, button, count label)</li>
        <li>ğŸ·ï¸ Add classes/IDs so you can select them</li>
        <li>ğŸ› ï¸ Update the DOM with <code>textContent</code>, classes, styles, etc.</li>
        <li>ğŸ–±ï¸ Attach event listeners manually</li>
      </ul>

      <h3>Example: Vanilla JS pattern ğŸ§±</h3>
      <pre><code>// 1) Select DOM elements
const adviceEl = document.querySelector(".advice");
const countEl  = document.querySelector(".count");
const btnEl    = document.querySelector(".btn");

// 2) Keep data ("state") in JS variables
let advice = "";
let count = 0;

// 3) Update UI manually
function render() {
  adviceEl.textContent = advice;
  countEl.textContent = String(count);
}

// 4) Handle events
btnEl.addEventListener("click", async () => {
  const res = await fetch("https://api.adviceslip.com/advice");
  const data = await res.json();

  advice = data.slip.advice;
  count = count + 1;

  render(); // manual UI sync
});</code></pre>

      <div class="callout">
        <p><strong>Observation</strong> ğŸ‘€</p>
        <p class="muted">
          Youâ€™re responsible for both the data updates <em>and</em> the UI updates. Thatâ€™s fine for tiny apps,
          but it grows quickly.
        </p>
      </div>
    </section>

    <section id="state">
      <h2>ğŸ§  State and UI sync (the core difference)</h2>
      <p>
        Both versions have â€œstate-likeâ€ values (example: <strong>advice</strong> and <strong>count</strong>).
        The key difference is what happens after you change them.
      </p>

      <div class="grid">
        <div class="card">
          <h3>React: update state â†’ React updates UI âœ…</h3>
          <pre><code>import { useState } from "react";

function App() {
  const [advice, setAdvice] = useState("");
  const [count, setCount] = useState(0);

  async function getAdvice() {
    const res = await fetch("https://api.adviceslip.com/advice");
    const data = await res.json();

    setAdvice(data.slip.advice);
    setCount(c =&gt; c + 1);
  }

  return (
    &lt;div&gt;
      &lt;h1&gt;{advice}&lt;/h1&gt;
      &lt;button onClick={getAdvice}&gt;Get advice&lt;/button&gt;
      &lt;p&gt;You have read &lt;strong&gt;{count}&lt;/strong&gt; pieces of advice.&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
          <p class="muted">No manual DOM selection. No <code>textContent</code> updates.</p>
        </div>

        <div class="card">
          <h3>Vanilla JS: update variables â†’ UI does NOT change unless you do it ğŸ§±</h3>
          <p class="muted">
            If you only change the variables, nothing happens visually. You must also write code that pushes those values into the DOM.
          </p>
          <pre><code>// Updating variables alone does not change the UI
count = count + 1;
advice = "New advice";

// You must still update the DOM manually
countEl.textContent = String(count);
adviceEl.textContent = advice;</code></pre>
        </div>
      </div>

      <div class="callout">
        <p><strong>Fundamental shift</strong> ğŸ”„</p>
        <p class="muted">
          Reactâ€™s big value is automatic UI synchronization. You focus on state changes; React takes care of the UI updates.
        </p>
      </div>
    </section>

    <section id="scale">
      <h2>ğŸ“ˆ Why it matters at scale</h2>
      <p>
        For a tiny app, manual DOM updates might feel manageable. But as the UI grows:
      </p>
      <ul>
        <li>ğŸ§© You end up selecting many elements</li>
        <li>ğŸª¢ You write lots of extra â€œglue codeâ€ to keep UI consistent</li>
        <li>ğŸ› Bugs become more likely when multiple parts update the DOM</li>
        <li>ğŸ Code can become tangled (â€œspaghetti codeâ€)</li>
      </ul>

      <div class="callout">
        <p><strong>Practical rule of thumb</strong> âœ…</p>
        <p class="muted">
          Vanilla JS is great for small scripts and simple pages. For interactive apps with many interconnected UI parts,
          React (or another framework) usually saves time and reduces complexity.
        </p>
      </div>
    </section>

    <section id="takeaways">
      <h2>âœ… Key takeaways</h2>
      <ul class="checklist">
        <li>âœ… React makes JavaScript â€œin chargeâ€ of UI through components + JSX</li>
        <li>âœ… In React, updating state automatically updates the UI</li>
        <li>âœ… In Vanilla JS, you must manually sync data to the DOM</li>
        <li>âœ… The difference becomes huge as app complexity grows</li>
        <li>âœ… Comparing both versions is a great way to understand the mindset shift</li>
      </ul>
    </section>

    <section id="self-check">
      <h2>ğŸ“ Quick self-check</h2>
      <ol>
        <li>What are the two â€œstate-likeâ€ values in the Advice App?</li>
        <li>In Vanilla JS, what extra steps are needed after updating variables?</li>
        <li>In React, what triggers the UI to update?</li>
        <li>Why does Vanilla JS code tend to grow faster in complex UIs?</li>
      </ol>

      <div class="callout">
        <p><strong>âœ… If you can answer these, you understood the core difference.</strong> ğŸ˜„</p>
      </div>
    </section>

    <footer>
      <p>
        Reviewer generated from the provided transcript. Designed for clean A4 printing (single column, word-wrapped).
      </p>
    </footer>
  </main>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>React Study Guide ‚Äî Server-side Sorting (Supabase order) + URL sortBy + React Query Cache</title>
  <style>
    :root{
      --bg:#ffffff;
      --text:#111111;
      --muted:#555555;
      --border:#e6e6e6;
      --panel:#fafafa;
      --chip:#f3f4f6;
      --link:#0b57d0;
      --shadow: 0 8px 30px rgba(0,0,0,.06);

      /* High-contrast code theme */
      --code-bg:#f5f5f5;
      --code-text:#111111;
      --code-border:#1f2937;
      --inline-bg:#eef2ff;
      --inline-border:#dbeafe;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height:1.65;
      overflow-wrap:anywhere;
      word-break:normal;
    }

    .page{
      max-width: 980px;
      margin: 0 auto;
      padding: 28px 18px 56px;
    }

    header{
      padding: 18px 18px;
      border:1px solid var(--border);
      border-radius: 14px;
      background: linear-gradient(180deg, #fff, var(--panel));
      box-shadow: var(--shadow);
    }

    h1{
      margin: 0 0 8px;
      font-size: 24px;
      letter-spacing: .2px;
      line-height: 1.25;
    }

    .subtitle{
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }

    .toolbar{
      margin-top: 14px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .btn{
      appearance:none;
      border:1px solid var(--border);
      background:#fff;
      border-radius: 10px;
      padding: 9px 12px;
      cursor:pointer;
      font-weight:600;
      font-size: 13px;
    }
    .btn:hover{ border-color:#cfcfcf; }
    .btn:active{ transform: translateY(1px); }

    .meta{
      margin-left:auto;
      color:var(--muted);
      font-size: 12px;
    }

    main{
      margin-top: 18px;
      padding: 18px;
      border:1px solid var(--border);
      border-radius: 14px;
      background:#fff;
      box-shadow: var(--shadow);
    }

    h2{
      margin: 18px 0 10px;
      font-size: 18px;
      line-height: 1.25;
    }
    h3{
      margin: 14px 0 8px;
      font-size: 15px;
      line-height: 1.3;
    }

    p{ margin: 8px 0; }
    ul{ margin: 8px 0 8px 20px; padding:0; }
    li{ margin: 6px 0; }

    .callout{
      border:1px solid var(--border);
      background: var(--panel);
      border-radius: 12px;
      padding: 12px 12px;
      margin: 12px 0;
    }

    .chips{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin: 10px 0 0;
      padding: 0;
      list-style:none;
    }
    .chip{
      background: var(--chip);
      border:1px solid var(--border);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      color:#222;
    }

    .divider{
      height:1px;
      background:var(--border);
      margin: 16px 0;
    }

    .small{ color:var(--muted); font-size: 13px; }

    /* Code blocks */
    code, pre{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
                   "Liberation Mono", "Courier New", monospace;
    }
    code{
      background: var(--inline-bg);
      color:#111111;
      padding: 1px 6px;
      border-radius: 6px;
      border: 1px solid var(--inline-border);
      font-size: 0.95em;
      opacity: 1 !important;
    }
    pre{
      margin: 10px 0;
      padding: 12px 14px;
      border-radius: 12px;
      background: var(--code-bg);
      color: var(--code-text);
      border: 1px solid var(--code-border);
      overflow:auto;
      max-width: 100%;
      box-shadow: 0 2px 14px rgba(0,0,0,.10);
      opacity: 1 !important;
    }
    pre code{
      background: transparent !important;
      border: 0 !important;
      padding: 0 !important;
      border-radius: 0 !important;
      color: inherit !important;
      font-size: 12.8px;
      line-height: 1.6;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
      word-break: break-word;
      opacity: 1 !important;
    }

    @media print{
      @page{ size: A4; margin: 12mm; }
      body{ background:#fff; }
      .page{ padding: 0; margin: 0; max-width: none; }
      header, main{ box-shadow: none; }
      header{ break-inside: avoid; }
      .toolbar{ display:none !important; }
      a[href]::after{ content:""; }

      pre{
        background:#ffffff !important;
        color:#111111 !important;
        border: 1px solid #d0d0d0 !important;
        box-shadow: none !important;
        overflow: visible !important;
      }
      pre code{
        white-space: pre-wrap !important;
        overflow-wrap: anywhere !important;
        word-break: break-word !important;
      }

      .callout{ break-inside: avoid; }
      h2{ break-after: avoid; }
    }
  </style>
</head>

<body>
  <div class="page">
    <header>
      <h1>‚ÜïÔ∏è Server-side Sorting ‚Äî Supabase <code>order()</code> + URL <code>sortBy</code> + React Query</h1>
      <p class="subtitle">
        Goal: perform sorting on the server (Supabase query), not in the browser.
        Flow: SortBy component updates <code>sortBy</code> in the URL ‚Üí <code>useBookings</code> reads it ‚Üí builds a sort object ‚Üí passes it into <code>getBookings</code> ‚Üí Supabase sorts with <code>order()</code>.
      </p>

      <div class="toolbar">
        <button class="btn" type="button" onclick="window.print()">üñ®Ô∏è Print / Save as PDF</button>
        <button class="btn" type="button" onclick="window.scrollTo({top:0,behavior:'smooth'})">‚¨ÜÔ∏è Back to Top</button>
        <span class="meta">Single-column ‚Ä¢ A4 print-ready ‚Ä¢ High-contrast code</span>
      </div>

      <ul class="chips" aria-label="key tags">
        <li class="chip">‚ÜïÔ∏è Sorting</li>
        <li class="chip">üóÉÔ∏è Supabase order()</li>
        <li class="chip">üîó URL sortBy</li>
        <li class="chip">‚ö° React Query cache</li>
        <li class="chip">üß© queryKey dependencies</li>
        <li class="chip">üß† field + direction</li>
      </ul>
    </header>

    <main>
      <h2>1) Why server-side sorting?</h2>
      <p>
        Sorting in the client can work for small datasets, but it becomes inefficient as data grows.
        With server-side sorting:
      </p>
      <ul>
        <li>‚úÖ You fetch data already sorted (less work on the client)</li>
        <li>‚úÖ Works well with pagination (you always get the correct slice, already ordered)</li>
        <li>‚úÖ Consistent results across devices and reloads (because sorting is driven by URL state)</li>
      </ul>

      <div class="divider"></div>

      <h2>2) Store ‚Äúsort by‚Äù in the URL</h2>
      <p>
        Your SortBy component writes something like <code>sortBy=startDate-desc</code> to the URL.
        Then <code>useBookings</code> reads it.
      </p>

      <div class="callout">
        <p><strong>‚úÖ Pattern (same as Filter)</strong></p>
        <p>
          UI component writes state ‚Üí Hook reads state ‚Üí Data fetching reacts to it.
        </p>
      </div>

      <h3>Read <code>sortBy</code> and split into field + direction</h3>
      <pre><code>// hooks/useBookings.js (conceptual)
import { useSearchParams } from "react-router-dom";

const [searchParams] = useSearchParams();

// 1) raw string from URL
const sortByRaw = searchParams.get("sortBy") || "startDate-desc";

// 2) split into two pieces
const [field, direction] = sortByRaw.split("-");

// 3) build an object
const sortBy = { field, direction };</code></pre>

      <div class="callout">
        <p><strong>üß† Why build a sort object?</strong></p>
        <ul>
          <li>Easier to pass around and use in queries.</li>
          <li>Makes the code more readable than working with strings everywhere.</li>
        </ul>
      </div>

      <div class="divider"></div>

      <h2>3) Add <code>sortBy</code> to the React Query queryKey</h2>
      <p>
        If sorting changes, you must refetch data. React Query does this automatically if the key changes.
      </p>

      <pre><code>// useQuery (conceptual)
const { data, isLoading } = useQuery({
  queryKey: ["bookings", filter, sortBy],
  queryFn: () =&gt; getBookings({ filter, sortBy }),
});</code></pre>

      <div class="callout">
        <p><strong>‚úÖ Think ‚Äúdependency array‚Äù</strong></p>
        <p>
          The queryKey behaves like dependencies: when any value changes (filter/sort),
          React Query fetches and caches a new result under that combination.
        </p>
      </div>

      <div class="divider"></div>

      <h2>4) Apply sorting inside the Supabase query using <code>order()</code></h2>
      <p>
        In <code>getBookings</code>, you conditionally add sorting:
      </p>

      <pre><code>// services/apiBookings.js (conceptual)
export async function getBookings({ filter, sortBy }) {
  let query = supabase.from("bookings").select("*");

  // ...filter logic...

  if (sortBy?.field) {
    query = query.order(sortBy.field, {
      ascending: sortBy.direction === "asc",
    });
  }

  const { data, error } = await query;
  if (error) throw error;
  return data;
}</code></pre>

      <div class="callout">
        <p><strong>‚ö†Ô∏è Important fix from the lecture</strong></p>
        <p>
          If you only pass the field, Supabase will sort, but you may not get the direction you expect.
          You must set <code>ascending</code> based on the direction string (<code>"asc"</code> vs <code>"desc"</code>).
        </p>
      </div>

      <h3>Why the lecture changes <code>if sort</code> instead of ‚Äú!= null‚Äù</h3>
      <p class="small">
        If no sort is passed, it will be <code>undefined</code> (not <code>null</code>), so the clean check is simply:
        <code>if (sortBy)</code> or <code>if (sortBy?.field)</code>.
      </p>

      <div class="divider"></div>

      <h2>5) Verify behavior in the UI</h2>
      <p>
        Once wired, you will see sorted dates correctly:
      </p>
      <ul>
        <li>Recent first ‚Üí newest startDate first</li>
        <li>Earlier first ‚Üí oldest startDate first</li>
      </ul>

      <div class="callout">
        <p><strong>‚úÖ Cache benefit</strong></p>
        <p>
          If you switch between sort options you used before, React Query may return data instantly from cache
          (same filter + same sort combination).
        </p>
      </div>

      <div class="divider"></div>

      <h2>6) How many cache combinations can exist?</h2>
      <p>
        In the lecture, there are multiple filter options and multiple sort options.
        Each unique combination can be cached separately, e.g.:
      </p>
      <ul>
        <li>4 filters √ó 4 sorts = 16 possible cached states</li>
      </ul>

      <div class="callout">
        <p><strong>Practical insight</strong></p>
        <p>
          This is why URL-driven state + React Query caching can make tables feel extremely fast after some interaction.
        </p>
      </div>

      <div class="divider"></div>

      <h2>7) Next step: pagination (the third key table operation)</h2>
      <p>
        Most real-world data tables have the ‚Äúbig three‚Äù:
      </p>
      <ul>
        <li>üîé Filter</li>
        <li>‚ÜïÔ∏è Sort</li>
        <li>üìÑ Pagination</li>
      </ul>

      <p class="small">
        Next lecture: implement pagination (including page state in the URL and server-side range queries).
      </p>

      <div class="divider"></div>

      <h2>8) Quick self-check (practice)</h2>
      <ul>
        <li>üîó Why store sort state in the URL?</li>
        <li>üß† Why split <code>sortByRaw</code> into <code>field</code> and <code>direction</code>?</li>
        <li>‚ö° Why must <code>sortBy</code> be included in the React Query queryKey?</li>
        <li>üóÉÔ∏è What does Supabase <code>order(field, { ascending })</code> do?</li>
        <li>üìÑ Why is server-side sorting especially important when you also add pagination?</li>
      </ul>

      <p class="small">
        End of reviewer. Next: build reusable pagination and connect it to the bookings table.
      </p>
    </main>
  </div>
</body>
</html>

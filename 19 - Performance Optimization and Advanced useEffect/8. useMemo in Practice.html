

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>React Performance ‚Äî useMemo in Practice (Study Guide)</title>
  <style>
    :root {
      --bg: #ffffff;
      --text: #111111;
      --muted: #555555;
      --border: #e6e6e6;
      --soft: #f7f7f7;
      --soft2: #fbfbfb;
      --codebg: #f5f5f5;
      --codefg: #111111;
      --accent: #1a73e8;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.6;
      overflow-wrap: anywhere;
      word-break: break-word;
    }

    /* Single-column layout */
    .page {
      max-width: 900px;
      margin: 0 auto;
      padding: 24px 18px 40px;
    }

    header {
      border: 1px solid var(--border);
      background: var(--soft2);
      padding: 18px 16px;
      border-radius: 12px;
    }

    h1 {
      margin: 0 0 6px;
      font-size: 22px;
      letter-spacing: 0.2px;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }

    .meta {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px dashed var(--border);
      color: var(--muted);
      font-size: 13px;
    }

    section {
      margin-top: 18px;
      padding: 16px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fff;
    }

    h2 {
      margin: 0 0 10px;
      font-size: 18px;
    }

    h3 {
      margin: 14px 0 8px;
      font-size: 15px;
    }

    p { margin: 8px 0; }

    ul, ol { margin: 8px 0 8px 20px; }
    li { margin: 6px 0; }

    .callout {
      border: 1px solid var(--border);
      background: var(--soft);
      border-left: 6px solid var(--accent);
      padding: 12px 12px;
      border-radius: 12px;
      margin: 10px 0;
    }

    .callout strong { display: inline-block; margin-bottom: 4px; }

    .warn {
      border-left-color: #d93025;
    }

    .ok {
      border-left-color: #188038;
    }

    .tip {
      border-left-color: #f9ab00;
    }

    code, pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
    }

    pre {
      margin: 10px 0;
      padding: 12px;
      background: var(--codebg);
      color: var(--codefg);
      border-radius: 12px;
      border: 1px solid #1f1f1f;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
      word-break: break-word;
    }

    .k {
      display: inline-block;
      padding: 2px 8px;
      border: 1px solid var(--border);
      background: var(--soft2);
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
      margin-right: 6px;
      margin-bottom: 6px;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .qa {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: #fff;
    }

    .divider {
      height: 1px;
      background: var(--border);
      margin: 12px 0;
    }

    /* Links: readable on screen, but print-safe */
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    /* Print: A4, clean margins, no URL expansion */
    @page { size: A4; margin: 14mm; }
    @media print {
      body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
      .page { max-width: none; padding: 0; }
      header, section { break-inside: avoid; page-break-inside: avoid; }
      a, a:visited { color: #000; text-decoration: none; }
      a[href]:after { content: ""; }
      pre { break-inside: avoid; }
    }
  </style>
</head>
<body>
  <main class="page">
    <header>
      <h1>üß† useMemo in Practice ‚Äî Fixing ‚Äúmemo broke because of object props‚Äù</h1>
      <p class="subtitle">React Performance Optimization (Atomic Blog / Archive example) ‚Äî reviewer & study guide</p>
      <p class="meta">
        <span class="k">üéØ Goal</span> Make object props <em>stable</em> so <code>memo()</code> can prevent wasted re-renders.
        <br />
        <span class="k">üß© Key idea</span> <code>useMemo</code> caches a value across renders until dependencies change.
      </p>
    </header>

    <section>
      <h2>1) Context: What problem are we fixing? üê¢</h2>
      <p>
        You memoized a heavy component (Archive). It became fast‚Ä¶ until you passed an <strong>object</strong> as a prop.
        After that, typing in the search field became laggy again.
      </p>

      <div class="callout warn">
        <strong>‚ö†Ô∏è The root cause</strong>
        <p>
          Objects created inside a component are <strong>recreated on every render</strong>. Even if the object <em>looks</em> the same,
          JavaScript treats it as a <strong>new reference</strong> each time.
        </p>
        <p>
          Result: the memoized child sees ‚Äúnew props‚Äù ‚Üí <code>memo()</code> can‚Äôt bail out ‚Üí heavy component re-renders ‚Üí UI lag.
        </p>
      </div>

      <h3>Quick mental model ‚úÖ</h3>
      <ul>
        <li>Render happens ‚Üí everything inside the component function runs again.</li>
        <li><code>{ show: false }</code> created now ‚â† <code>{ show: false }</code> created before (different references).</li>
        <li><code>memo(Archive)</code> only skips re-render if props are <strong>shallow-equal</strong> (same references for objects/functions).</li>
      </ul>
    </section>

    <section>
      <h2>2) The fix: useMemo to stabilize the object üîí</h2>
      <p>
        We use <code>useMemo</code> to <strong>cache</strong> the object, so React reuses the same object reference across re-renders.
      </p>

      <div class="callout ok">
        <strong>‚úÖ What useMemo does (in plain words)</strong>
        <p>
          ‚ÄúRun this function once, keep the returned value in memory, and reuse it in future renders ‚Äî unless dependencies change.‚Äù
        </p>
      </div>

      <h3>Before: object prop breaks memoization ‚ùå</h3>
      <pre><code>// App component
const archiveOptions = { show: false, title: "Post archive" };

return (
  &lt;Archive archiveOptions={archiveOptions} /&gt;
);
</code></pre>

      <h3>After: memoize the object with useMemo ‚úÖ</h3>
      <pre><code>import { useMemo } from "react";

// App component
const archiveOptions = useMemo(
  () =&gt; ({ show: false, title: "Post archive" }),
  []
);

return (
  &lt;Archive archiveOptions={archiveOptions} /&gt;
);
</code></pre>

      <div class="callout tip">
        <strong>üõ†Ô∏è Why useMemo takes a function</strong>
        <p>
          Because often you‚Äôre caching the result of an expensive computation.
          React calls your function and caches whatever it returns.
        </p>
      </div>

      <h3>Dependency array: the rule of when it recalculates üîÅ</h3>
      <ul>
        <li><code>[]</code> ‚Üí compute once on mount; never recompute.</li>
        <li><code>[x, y]</code> ‚Üí recompute only when <code>x</code> or <code>y</code> changes.</li>
      </ul>
    </section>

    <section>
      <h2>3) Adding dependencies: avoiding stale values üßä</h2>
      <p>
        If your memoized value depends on changing state/props, you must include that dependency.
        Otherwise, React keeps returning the cached value (which becomes outdated).
      </p>

      <h3>Example: title depends on number of posts</h3>
      <pre><code>// posts is state in App
const archiveOptions = useMemo(
  () =&gt; ({
    show: false,
    title: `Post archive (in addition to ${posts.length} main posts)`,
  }),
  [posts.length]
);
</code></pre>

      <div class="callout warn">
        <strong>‚ö†Ô∏è If you forget the dependency</strong>
        <p>
          The UI can show an old number like ‚Äú30‚Äù even after you added posts.
          That‚Äôs a classic ‚Äústale value‚Äù situation.
        </p>
      </div>

      <h3>Stale closure explained (beginner-friendly)</h3>
      <p>
        When <code>useMemo</code> runs, it creates a function closure that ‚Äúremembers‚Äù the values it used at that time.
        If <code>useMemo</code> never runs again (because dependencies don‚Äôt change), it keeps using those old remembered values.
      </p>

      <div class="callout tip">
        <strong>üìå Dependency best practice</strong>
        <p>
          Prefer primitives in dependency arrays when possible (like <code>posts.length</code>) because they‚Äôre easier to compare and reason about.
          Objects/arrays/functions often change reference too easily.
        </p>
      </div>
    </section>

    <section>
      <h2>4) Important consequence: it can still re-render sometimes üß™</h2>
      <p>
        After you add <code>[posts.length]</code>, the object changes whenever the number of posts changes.
        That means your memoized Archive can still re-render ‚Äî and that‚Äôs correct.
      </p>

      <div class="callout">
        <strong>üß† The key idea</strong>
        <p>
          <code>memo(Archive)</code> skips re-render <em>only</em> when props are unchanged.
          If the title changes (because <code>posts.length</code> changed), props changed ‚Üí Archive must update.
        </p>
      </div>

      <h3>What you should expect in the Profiler</h3>
      <ul>
        <li>Typing in search input: Archive should <strong>not</strong> re-render (fast typing again).</li>
        <li>Adding a post: Archive <strong>may</strong> re-render (because props legitimately changed).</li>
      </ul>
    </section>

    <section>
      <h2>5) When to use useMemo (quick rules) ‚úÖ</h2>
      <div class="grid">
        <div class="qa">
          <h3>‚úÖ Use useMemo when‚Ä¶</h3>
          <ul>
            <li>You pass an object/array as a prop to a <code>memo()</code>-ized child.</li>
            <li>You have an expensive calculation you don‚Äôt want to repeat on every render.</li>
            <li>You need a stable value for another hook‚Äôs dependency array.</li>
          </ul>
        </div>

        <div class="qa">
          <h3>üö´ Avoid useMemo when‚Ä¶</h3>
          <ul>
            <li>The component/value is cheap and renders rarely (no noticeable cost).</li>
            <li>You are ‚Äúmemoizing everything‚Äù without evidence (adds complexity).</li>
            <li>The dependencies change almost every render (little or no benefit).</li>
          </ul>
        </div>
      </div>

      <div class="divider"></div>

      <h3>Mini self-check (fast quiz) üìù</h3>
      <ol>
        <li>Why did passing an object prop break <code>memo()</code>?</li>
        <li>What does <code>[]</code> mean in <code>useMemo(fn, [])</code>?</li>
        <li>What happens if you forget dependencies like <code>posts.length</code>?</li>
      </ol>

      <div class="callout ok">
        <strong>‚úÖ Key takeaways</strong>
        <ul>
          <li><code>memo()</code> relies on stable props (same references for objects/functions).</li>
          <li><code>useMemo</code> stabilizes values across renders based on dependencies.</li>
          <li>Correct dependencies prevent stale UI and confusing bugs.</li>
        </ul>
      </div>

      <p><strong>Next topic:</strong> üîú <code>useCallback</code> (same idea, but for stabilizing functions).</p>
    </section>
  </main>
</body>
</html>
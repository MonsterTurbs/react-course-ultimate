

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>React â€” Using Helper Functions in Effects (Study Guide)</title>
  <style>
    :root {
      --bg: #ffffff;
      --text: #111111;
      --muted: #555555;
      --border: #e6e6e6;
      --soft: #fafafa;
      --chip: #f3f4f6;
      --callout: #f7f7ff;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.6;
      overflow-wrap: anywhere;
      word-break: normal;
    }

    /* Single-column page */
    .page {
      max-width: 820px;
      margin: 0 auto;
      padding: 28px 18px 40px;
    }

    header {
      border: 1px solid var(--border);
      background: var(--soft);
      padding: 16px 16px 14px;
      border-radius: 10px;
    }

    h1 {
      font-size: 22px;
      margin: 0 0 6px;
      line-height: 1.25;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }

    .meta {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      background: var(--chip);
      border: 1px solid var(--border);
      font-size: 12px;
      color: #222;
      white-space: nowrap;
    }

    section {
      margin-top: 16px;
      padding: 14px 14px 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
    }

    h2 {
      font-size: 16px;
      margin: 0 0 10px;
      line-height: 1.3;
    }

    h3 {
      font-size: 14px;
      margin: 12px 0 8px;
      line-height: 1.3;
    }

    p { margin: 0 0 10px; }

    ul {
      margin: 8px 0 12px;
      padding-left: 20px;
    }
    li { margin: 6px 0; }

    .callout {
      background: var(--callout);
      border: 1px solid #dcdcff;
      border-radius: 10px;
      padding: 12px 12px 10px;
      margin: 10px 0 12px;
    }

    .callout strong { display: inline-block; margin-bottom: 4px; }

    code, pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
    }

    pre {
      background: #f5f5f5;
      color: #111111;
      padding: 12px;
      border-radius: 10px;
      overflow: auto;
      border: 1px solid #1c1c1f;
      margin: 10px 0 12px;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .qa {
      border-top: 1px dashed var(--border);
      margin-top: 10px;
      padding-top: 10px;
    }

    .small { color: var(--muted); font-size: 12.5px; }

    /* Print */
    @page { size: A4; margin: 14mm; }
    @media print {
      body { background: #fff; }
      .page { max-width: none; padding: 0; }
      header, section { break-inside: avoid; }
      a, a:visited { color: inherit; text-decoration: none; }
      a[href]:after { content: ""; } /* do not print URLs */
      pre { border: 1px solid #000; }
    }
  </style>
</head>
<body>
  <main class="page">
    <header>
      <h1>ğŸ”Š Using Helper Functions in <code>useEffect</code> (Advanced Dependency Strategies)</h1>
      <p class="subtitle">Goal: play a sound when <code>duration</code> changesâ€”without breaking state sync or causing confusing side effects.</p>
      <div class="meta">
        <span class="chip">ğŸ§  Topic: useEffect deps</span>
        <span class="chip">ğŸª Hooks: useEffect, useCallback</span>
        <span class="chip">âš ï¸ Theme: reactive values + stale behavior</span>
        <span class="chip">âœ… Pattern: 1 effect = 1 side effect</span>
      </div>
    </header>

    <section>
      <h2>ğŸ¯ What you will learn</h2>
      <ul>
        <li>Why a â€œhelper functionâ€ can become a <em>reactive value</em> and must be listed as a dependency.</li>
        <li>How putting a helper function in a dependency array can accidentally trigger <strong>extra effect runs</strong> and reset state.</li>
        <li>When and why to memoize a function using <code>useCallback</code>.</li>
        <li>Why separating responsibilities into multiple effects makes behavior clearer (and fixes bugs).</li>
      </ul>

      <div class="callout">
        <strong>ğŸ’¡ Key mindset</strong>
        <p>Effects run <em>after render</em>. If an effect sets state, you will likely get an additional render. So you must design effects to be predictable and intentional.</p>
      </div>
    </section>

    <section>
      <h2>ğŸ§© The setup: â€œplay a sound when duration changesâ€</h2>
      <p>We have a timer/workout app with <code>duration</code> state. We want sound feedback whenever <code>duration</code> changes.</p>

      <h3>âœ… Helper function to play audio</h3>
      <p class="small">(Browser Audio API: create <code>new Audio()</code> and call <code>.play()</code>)</p>
      <pre><code>// Example helper (simplified)
import clickSound from "./click.mp3";

function playSound() {
  const sound = new Audio(clickSound);
  sound.play();
}</code></pre>

      <div class="callout">
        <strong>âš ï¸ Browser note</strong>
        <p>Many browsers block autoplay: the user must interact (click, keypress) before audio can play. So the first sound may fail until the first interaction.</p>
      </div>
    </section>

    <section>
      <h2>ğŸ§¨ The first attempt (and why it breaks)</h2>
      <p>You might try calling <code>playSound()</code> in multiple places:</p>
      <ul>
        <li>Inside manual buttons: increment/decrement handlers</li>
        <li>Inside the effect that syncs <code>duration</code> with other state values</li>
      </ul>

      <h3>Problem 1: <code>playSound</code> becomes a reactive value</h3>
      <p>If <code>playSound</code> uses <code>allowSound</code> (from state/props), then <code>playSound</code> is reactive too.</p>

      <pre><code>// Reactive helper: depends on allowSound (state/prop)
function playSound() {
  if (!allowSound) return;
  const sound = new Audio(clickSound);
  sound.play();
}

useEffect(() =&gt; {
  setDuration(/* compute from number, sets, speed, breakLength */);
  playSound();
}, [number, sets, speed, breakLength, playSound]);</code></pre>

      <h3>Problem 2: duration â€œflickersâ€ and sound plays twice ğŸ˜µâ€ğŸ’«</h3>
      <p>What happens when you click a button that updates <code>duration</code>?</p>
      <ul>
        <li>Button handler sets <code>duration</code> (and plays sound)</li>
        <li>State update triggers re-render</li>
        <li>Re-render recreates <code>playSound</code> (new function reference)</li>
        <li>Because <code>playSound</code> is in deps, the effect runs again</li>
        <li>The effect recomputes duration from other inputs (which didnâ€™t change), and overwrites your manual duration</li>
      </ul>

      <div class="callout">
        <strong>ğŸ” Diagnosis</strong>
        <p>You didnâ€™t â€œdo something wrongâ€ by listing <code>playSound</code>. You did the correct thing by not lying to React. The real issue is: the effect is doing <em>two jobs</em> (sync duration + play audio), and the helperâ€™s identity changes across renders.</p>
      </div>
    </section>

    <section>
      <h2>ğŸ› ï¸ Strategy A: Memoize the helper function with <code>useCallback</code></h2>
      <p>When you need a helper function in multiple places, and it depends on reactive values, memoize it to stabilize its identity.</p>

      <pre><code>const playSound = useCallback(() =&gt; {
  if (!allowSound) return;
  const sound = new Audio(clickSound);
  sound.play();
}, [allowSound]);</code></pre>

      <p><strong>Result:</strong> the function is not recreated every renderâ€”only when <code>allowSound</code> changes.</p>

      <div class="callout">
        <strong>ğŸ§  Why <code>clickSound</code> is not in deps?</strong>
        <p>Imported modules/constants are stable references in typical bundler setups, so they donâ€™t need to be listed unless your linting setup flags them (rare for static imports).</p>
      </div>

      <h3>Butâ€¦ we can still get surprising behavior ğŸ¤¯</h3>
      <ul>
        <li>Toggling <code>allowSound</code> changes the memoized function</li>
        <li>That can retrigger effects that depend on <code>playSound</code></li>
        <li>Which can cause duration recalculation and unexpected resets</li>
      </ul>

      <p class="small">This is a real-world reason advanced hook logic can feel confusing: hooks interact through dependency arrays and identity changes.</p>
    </section>

    <section>
      <h2>âœ… Strategy B (Best): One effect per side effect</h2>
      <p>Instead of mixing â€œsync durationâ€ and â€œplay soundâ€ inside the same effect, split them into separate effects:</p>

      <div class="grid">
        <div class="callout">
          <strong>1) â±ï¸ Effect for syncing duration</strong>
          <p class="small">Only responsible for updating <code>duration</code> from the base inputs.</p>
          <pre><code>useEffect(() =&gt; {
  setDuration(
    // formula based on number, sets, speed, breakLength
  );
}, [number, sets, speed, breakLength]);</code></pre>
        </div>

        <div class="callout">
          <strong>2) ğŸ”Š Effect for playing sound</strong>
          <p class="small">Only responsible for audio feedback when duration changes.</p>
          <pre><code>function playSound() {
  if (!allowSound) return;
  const sound = new Audio(clickSound);
  sound.play();
}

useEffect(() =&gt; {
  playSound();
}, [duration, allowSound]);</code></pre>
        </div>
      </div>

      <h3>Why this is better</h3>
      <ul>
        <li>âœ… Very intentional: â€œsound follows durationâ€</li>
        <li>âœ… No need to call sound in multiple places</li>
        <li>âœ… Avoids accidental resets when toggling sound or re-creating helpers</li>
        <li>âœ… Cleaner mental model and easier debugging</li>
      </ul>

      <div class="callout">
        <strong>ğŸ§· Small detail</strong>
        <p>It is okay to list <code>duration</code> as a dependency even if you donâ€™t â€œuseâ€ it directly in the effect body. Youâ€™re declaring the synchronization rule: run when <code>duration</code> changes.</p>
      </div>
    </section>

    <section>
      <h2>ğŸ“Œ Rules & reminders (quick checklist)</h2>
      <ul>
        <li>âœ… List <strong>all reactive values</strong> used by an effect (state, props, context, and values that reference them).</li>
        <li>ğŸš« Donâ€™t â€œfixâ€ deps warnings by deleting deps. Fix the underlying design.</li>
        <li>ğŸ§° Helper-function strategies:
          <ul>
            <li>Move the helper <strong>outside</strong> the component (only if it uses no reactive values).</li>
            <li>Move the helper <strong>inside the effect</strong> (if you only need it there).</li>
            <li>Use <code>useCallback</code> (if you need it in multiple places and it depends on reactive values).</li>
          </ul>
        </li>
        <li>âœ… Prefer: <strong>one effect per side effect</strong> (one effect = one responsibility).</li>
      </ul>
    </section>

    <section>
      <h2>ğŸ§ª Mini self-test</h2>
      <div class="qa">
        <p><strong>Q1:</strong> Why did adding <code>playSound</code> to the dependency array cause the duration to â€œsnap backâ€ after clicking +/âˆ’?</p>
        <p class="small"><strong>Answer idea:</strong> The helper function was recreated after re-render, retriggering the duration-sync effect, which overwrote the manual duration using unchanged base inputs.</p>
      </div>

      <div class="qa">
        <p><strong>Q2:</strong> When should you choose <code>useCallback</code>?</p>
        <p class="small"><strong>Answer idea:</strong> When you must keep a function stable across renders (identity), especially if itâ€™s used as a dependency or passed to memoized children.</p>
      </div>

      <div class="qa">
        <p><strong>Q3:</strong> Whatâ€™s the cleanest design to â€œplay sound whenever duration changesâ€?</p>
        <p class="small"><strong>Answer idea:</strong> A dedicated <code>useEffect</code> that depends on <code>duration</code> (and <code>allowSound</code>) and only plays audio.</p>
      </div>
    </section>

    <section>
      <h2>âœ… Takeaway</h2>
      <p><strong>Best practice:</strong> Keep effects focused. If you need to synchronize multiple side effects, split them into multiple effects so each one is predictable. ğŸ˜Œ</p>
      <p class="small">Next: applying these patterns in more complex real-world scenarios where multiple hooks interact.</p>
    </section>

  </main>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Redux Middleware and Thunks â€” Study Guide (Print-Friendly)</title>
  <style>
    :root {
      --bg: #ffffff;
      --text: #111111;
      --muted: #555555;
      --border: #e6e6e6;
      --panel: #fafafa;
      --codebg: #f5f5f5;   /* light gray */
      --codetext: #111111; /* optional: make text dark */
      --chip: #f3f4f6;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.6;
      overflow-wrap: anywhere;
      word-break: break-word;
    }

    /* Single-column page container */
    .page {
      max-width: 850px;
      margin: 0 auto;
      padding: 24px;
    }

    header {
      padding: 16px 16px 12px;
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: 12px;
    }

    h1 {
      margin: 0 0 6px;
      font-size: 26px;
      letter-spacing: -0.2px;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }

    .meta {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      background: var(--chip);
      border: 1px solid var(--border);
      font-size: 12px;
      color: #222;
      white-space: nowrap;
    }

    main { padding-top: 16px; }

    section {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin: 12px 0;
      background: #fff;
      break-inside: avoid;
    }

    h2 {
      margin: 0 0 10px;
      font-size: 18px;
      letter-spacing: -0.15px;
    }

    h3 {
      margin: 14px 0 8px;
      font-size: 15px;
    }

    p { margin: 8px 0; }

    ul { margin: 8px 0 0; padding-left: 22px; }
    li { margin: 6px 0; }

    .callout {
      border-left: 5px solid #c7c7c7;
      background: #fbfbfb;
      padding: 10px 12px;
      border-radius: 10px;
      margin-top: 10px;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    pre {
      margin: 10px 0 0;
      padding: 12px;
      background: var(--codebg);
      color: var(--codetext);
      border-radius: 12px;
      overflow: auto;
      border: 1px solid #111827;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .mini {
      font-size: 13px;
      color: var(--muted);
    }

    .diagram {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: #fcfcfc;
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 12px;
      margin-top: 10px;
      white-space: pre-wrap;
    }

    /* Links should look normal on screen */
    a { color: inherit; text-decoration: underline; }

    /* Print settings */
    @page {
      size: A4;
      margin: 14mm;
    }

    @media print {
      body { background: #fff; }
      .page { padding: 0; max-width: none; }
      header, section { border-radius: 0; }

      /* Avoid printing URL after links */
      a[href]::after { content: "" !important; }

      /* Better print colors */
      * { -webkit-print-color-adjust: exact; print-color-adjust: exact; }

      /* Avoid breaking code blocks awkwardly */
      pre, .diagram, section { break-inside: avoid; page-break-inside: avoid; }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <h1>Redux Middleware and Thunks</h1>
      <p class="subtitle">Study guide / reviewer â€” print-friendly (A4), single-column layout</p>
      <div class="meta">
        <span class="chip">ğŸ§  Topic: Redux async logic</span>
        <span class="chip">âš™ï¸ Concept: Middleware</span>
        <span class="chip">â³ Tool: Redux Thunk</span>
        <span class="chip">âœ… Goal: Keep reducers pure</span>
      </div>
    </header>

    <main>
      <section>
        <h2>ğŸ¯ What youâ€™re learning in this lecture</h2>
        <ul>
          <li>Why <strong>reducers must stay pure</strong> (no side effects, no async).</li>
          <li>Where async logic belongs in Redux (hint: <strong>middleware</strong>).</li>
          <li>How <strong>Redux Thunk</strong> lets Redux â€œwaitâ€ before dispatching.</li>
          <li>Common side effects middleware can handle: API calls, timers, logging, canceling actions.</li>
        </ul>
        <div class="callout">
          <p><strong>Key idea:</strong> Middleware is the <em>go-to place</em> for side effects in the Redux cycle. ğŸ§©</p>
        </div>
      </section>

      <section>
        <h2>ğŸ§± Quick refresher: The normal Redux cycle (no middleware)</h2>
        <p>Without middleware, Redux is <strong>synchronous</strong> by default:</p>
        <div class="diagram" aria-label="Redux cycle diagram">
Component
  â†“ dispatch(action)
Store
  â†“ runs reducer(action)
Reducer (pure)
  â†“ returns nextState
Store updates state
  â†“
UI re-renders (subscribed components)
        </div>
        <p class="mini">âœ… Works great for synchronous updates (deposit, withdraw, toggle UI, etc.).</p>
      </section>

      <section>
        <h2>ğŸš« Why you canâ€™t fetch data inside a reducer</h2>
        <p>Reducers must be <strong>pure functions</strong>. That means:</p>
        <ul>
          <li>ğŸš« No API requests / <code>fetch</code> / <code>axios</code></li>
          <li>ğŸš« No timers / <code>setTimeout</code></li>
          <li>ğŸš« No random numbers / date side effects (unless passed in)</li>
          <li>ğŸš« No direct mutation of existing state</li>
        </ul>
        <div class="callout">
          <p>ğŸ§¼ Reducers should only do one job: <strong>(state, action) â†’ nextState</strong>.</p>
        </div>
      </section>

      <section>
        <h2>â“ So where do async operations happen?</h2>
        <p>You have three places you might think about:</p>
        <ul>
          <li><strong>Reducer</strong> â€” not allowed (must be pure).</li>
          <li><strong>Components</strong> â€” possible, but not ideal if it spreads data-fetching everywhere.</li>
          <li><strong>Middleware</strong> â€” the intended solution for side effects. âœ…</li>
        </ul>
        <p><strong>Why not in components?</strong> Because we often want:</p>
        <ul>
          <li>ğŸ§¹ Cleaner UI components (focus on rendering + user interaction)</li>
          <li>ğŸ“¦ Data-fetching logic centralized (one place, easier to test and maintain)</li>
        </ul>
      </section>

      <section>
        <h2>ğŸ§© What is Redux Middleware?</h2>
        <p><strong>Middleware</strong> is a function that sits <strong>between dispatching an action and the reducer</strong>.</p>
        <p>It lets you run code:</p>
        <ul>
          <li>âœ… <strong>after</strong> <code>dispatch(action)</code> happens</li>
          <li>âœ… but <strong>before</strong> the action reaches reducers</li>
        </ul>
        <div class="diagram" aria-label="Redux with middleware diagram">
Component
  â†“ dispatch(action)
Middleware (runs side effects)
  â†“ optionally transforms / delays / cancels action
Store â†’ Reducers
  â†“
State updates â†’ UI re-renders
        </div>

        <h3>ğŸ”§ What middleware can do</h3>
        <ul>
          <li>ğŸŒ Fetch data from an API</li>
          <li>â±ï¸ Start timers</li>
          <li>ğŸªµ Log actions/state</li>
          <li>ğŸ›‘ Pause or cancel actions</li>
        </ul>
      </section>

      <section>
        <h2>âš¡ Redux Thunk (most common async middleware)</h2>
        <p><strong>Redux Thunk</strong> is a popular middleware that enables async logic by allowing you to dispatch:</p>
        <ul>
          <li>âœ… normal action objects (e.g., <code>{ type, payload }</code>)</li>
          <li>âœ… <strong>functions</strong> (thunks) that can run async work, then dispatch real actions later</li>
        </ul>

        <div class="callout">
          <p><strong>Thunk = â€œdeferred dispatchâ€</strong> â³</p>
          <p>Instead of dispatching data immediately, you <em>wait</em> for it to arrive, then dispatch the final action.</p>
        </div>

        <h3>ğŸ§  Mental model (what happens with Thunk)</h3>
        <ol>
          <li>Dispatch enters the thunk middleware first.</li>
          <li>The thunk runs async work (e.g., fetch).</li>
          <li>When data arrives, thunk dispatches a normal action into the store.</li>
          <li>Reducers update state, UI re-renders.</li>
        </ol>
      </section>

      <section>
        <h2>ğŸ§ª Practical example (beginner-friendly)</h2>
        <p>Below is a simple â€œfetch userâ€ flow using thunk-style logic.</p>

        <h3>1) Actions (request / success / error)</h3>
        <pre><code>// usersSlice.js (classic Redux style)
const initialState = { data: null, status: "idle", error: null };

export default function usersReducer(state = initialState, action) {
  switch (action.type) {
    case "users/request":
      return { ...state, status: "loading", error: null };
    case "users/success":
      return { ...state, status: "succeeded", data: action.payload };
    case "users/error":
      return { ...state, status: "failed", error: action.payload };
    default:
      return state;
  }
}

export const usersRequest = () =&gt; ({ type: "users/request" });
export const usersSuccess = (user) =&gt; ({ type: "users/success", payload: user });
export const usersError = (message) =&gt; ({ type: "users/error", payload: message });
</code></pre>

        <h3>2) The thunk (async function that dispatches later)</h3>
        <pre><code>// usersThunks.js
import { usersRequest, usersSuccess, usersError } from "./usersSlice";

// A thunk is a function that returns another function.
// Thunk middleware will call it and give it (dispatch, getState).
export function fetchUser(userId) {
  return async function (dispatch, getState) {
    try {
      dispatch(usersRequest());

      const res = await fetch(`https://api.example.com/users/${userId}`);
      if (!res.ok) throw new Error("Request failed");

      const data = await res.json();
      dispatch(usersSuccess(data));
    } catch (err) {
      dispatch(usersError(err.message));
    }
  };
}
</code></pre>

        <h3>3) Dispatching the thunk from a component</h3>
        <pre><code>// SomeComponent.jsx
import { useDispatch } from "react-redux";
import { fetchUser } from "./usersThunks";

export default function SomeComponent() {
  const dispatch = useDispatch();

  function handleLoad() {
    dispatch(fetchUser(123));
  }

  return (
    &lt;button onClick={handleLoad}&gt;
      Load user
    &lt;/button&gt;
  );
}
</code></pre>

        <p class="mini">âœ… Notice: reducers stay pure; async work happens in the thunk (middleware-driven flow).</p>
      </section>

      <section>
        <h2>âœ… Quick checklist (what to remember)</h2>
        <ul>
          <li>ğŸ§¼ Reducers must be pure â†’ no async and no side effects.</li>
          <li>ğŸ§© Middleware runs <em>between</em> dispatch and reducers.</li>
          <li>ğŸŒ Thunks are ideal for async work: fetch â†’ then dispatch.</li>
          <li>ğŸ§  Think: â€œThunk lets Redux wait before final dispatch.â€</li>
        </ul>
        <div class="callout">
          <p><strong>Retention tip:</strong> If your code is doing <em>work over time</em> (fetching, waiting, retrying) â†’ thatâ€™s a strong signal it belongs in <strong>middleware/thunks</strong>, not reducers. âœ…</p>
        </div>
      </section>

      <section>
        <h2>ğŸ“ Mini self-test</h2>
        <ol>
          <li>Why canâ€™t reducers call <code>fetch()</code>? ğŸ¤”</li>
          <li>Where does middleware sit in the Redux flow?</li>
          <li>In one sentence, what is a thunk?</li>
          <li>What is the benefit of centralizing fetching logic outside components?</li>
        </ol>
      </section>
    </main>
  </div>
</body>
</html>
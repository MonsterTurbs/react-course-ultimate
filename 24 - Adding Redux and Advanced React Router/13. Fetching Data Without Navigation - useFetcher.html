

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fetching Data Without Navigation â€” React Router useFetcher (Study Guide)</title>
  <style>
    :root {
      --bg: #ffffff;
      --text: #111111;
      --muted: #555555;
      --border: #e6e6e6;
      --soft: #fafafa;
      --codebg: #f7f7f9;
      --warn: #8a4b00;
      --ok: #0b7a2a;
      --info: #0b57d0;
      --danger: #b00020;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.55;
      overflow-wrap: anywhere;
      word-break: normal;
    }

    /* Single-column layout */
    .page {
      max-width: 920px;
      margin: 0 auto;
      padding: 28px 18px 36px;
    }

    header {
      border: 1px solid var(--border);
      background: var(--soft);
      padding: 18px 16px;
      border-radius: 10px;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 1.55rem;
      letter-spacing: 0.1px;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 0.98rem;
    }

    .meta {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      border: 1px solid var(--border);
      background: #fff;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.9rem;
      color: var(--muted);
      white-space: nowrap;
    }

    main { margin-top: 18px; }

    section {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      margin: 14px 0;
      background: #fff;
    }

    h2 {
      margin: 0 0 10px;
      font-size: 1.2rem;
    }

    h3 {
      margin: 14px 0 8px;
      font-size: 1.05rem;
    }

    p { margin: 8px 0; }

    ul, ol {
      margin: 8px 0 0 22px;
      padding: 0;
    }

    li { margin: 6px 0; }

    .callout {
      border-left: 4px solid var(--border);
      background: var(--soft);
      padding: 10px 12px;
      border-radius: 8px;
      margin: 10px 0;
    }

    .callout strong { color: var(--text); }
    .callout.warn { border-left-color: var(--warn); }
    .callout.ok { border-left-color: var(--ok); }
    .callout.info { border-left-color: var(--info); }
    .callout.danger { border-left-color: var(--danger); }

    code, pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    pre {
      margin: 10px 0;
      padding: 12px;
      background: var(--codebg);
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: auto;
      white-space: pre;
      tab-size: 2;
    }

    .divider {
      height: 1px;
      background: var(--border);
      margin: 12px 0;
    }

    .two-col {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    @media (min-width: 860px) {
      .two-col { grid-template-columns: 1fr 1fr; }
    }

    /* Print rules */
    @page {
      size: A4;
      margin: 18mm;
    }

    @media print {
      body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
      .page { max-width: none; padding: 0; }
      header, section { break-inside: avoid; page-break-inside: avoid; }
      a { color: inherit; text-decoration: none; }
      pre { overflow: visible; white-space: pre-wrap; word-break: break-word; }
      .chip { border-color: #dcdcdc; }
    }
  </style>
</head>

<body>
  <div class="page">
    <header>
      <h1>ğŸ§² Fetching Data Without Navigation â€” <code>useFetcher</code> (React Router)</h1>
      <p class="subtitle">
        Study guide from the lecture transcript: use React Routerâ€™s <code>useFetcher</code> to load data from another routeâ€™s loader (Menu) while staying on the current page (Order), then enrich order items with ingredients.
      </p>
      <div class="meta">
        <span class="chip">ğŸ§© Hook: <code>useFetcher()</code></span>
        <span class="chip">ğŸ“¥ Method: <code>fetcher.load("/menu")</code></span>
        <span class="chip">â³ States: idle / loading / submitting</span>
        <span class="chip">ğŸ§  Pattern: fetch on mount with <code>useEffect</code></span>
        <span class="chip">ğŸ• Goal: show ingredients per ordered pizza</span>
      </div>
    </header>

    <main>
      <section>
        <h2>ğŸ¯ What problem are we solving?</h2>
        <p>
          Sometimes you need data that belongs to a <strong>different route</strong>, but you donâ€™t want the user to
          actually navigate there.
        </p>
        <p>
          In this lesson, you are on the <strong>Order</strong> page, but you want to reuse the <strong>Menu loader</strong>
          to get pizza ingredient lists.
        </p>
        <div class="callout info">
          <p><strong>Example</strong></p>
          <p>
            You want to show: â€œIngredients: tomato, mozzarella, basilâ€ under each ordered pizza â€” but ingredients live
            in the Menu data.
          </p>
        </div>
      </section>

      <section>
        <h2>ğŸ§  Key idea: <code>useFetcher</code> loads data without navigation</h2>
        <p>
          <code>useFetcher()</code> gives you a <strong>fetcher object</strong> that can:
        </p>
        <ul>
          <li>ğŸ“¥ Load data from a route loader (<code>fetcher.load</code>)</li>
          <li>ğŸ§¾ Submit data to a route action (<code>fetcher.submit</code>) â€” not used yet in this lecture, but same idea</li>
          <li>â³ Track state (<code>fetcher.state</code>)</li>
          <li>ğŸ“¦ Hold result (<code>fetcher.data</code>)</li>
        </ul>

        <div class="two-col">
          <div class="callout">
            <p><strong>Navigation (normal)</strong></p>
            <p>
              User clicks link â†’ route changes â†’ loader runs â†’ UI changes
            </p>
          </div>
          <div class="callout ok">
            <p><strong>Fetcher (no navigation)</strong></p>
            <p>
              Stay on the same route â†’ fetch another routeâ€™s data â†’ UI updates
            </p>
          </div>
        </div>
      </section>

      <section>
        <h2>ğŸ§± Step 1: Create the fetcher</h2>
        <pre><code>// Order.jsx (conceptual)
import { useFetcher } from "react-router-dom";

function Order() {
  const fetcher = useFetcher();

  // ...
}
</code></pre>

        <div class="callout">
          <p><strong>Remember</strong></p>
          <p>
            The data you load will appear on <code>fetcher.data</code> when the request finishes.
          </p>
        </div>
      </section>

      <section>
        <h2>â±ï¸ Step 2: Load menu data on component mount</h2>
        <p>
          Because you want to fetch immediately when the Order page appears, you use <code>useEffect</code>.
        </p>

        <pre><code>// Order.jsx (conceptual)
import { useEffect } from "react";

useEffect(() =&gt; {
  // Only load if we don't already have data
  if (!fetcher.data &amp;&amp; fetcher.state === "idle") {
    fetcher.load("/menu");
  }
}, [fetcher]);
</code></pre>

        <div class="callout warn">
          <p><strong>Common bug from the transcript</strong></p>
          <p>
            Use <code>fetcher.state</code>, not <code>fetcher.status</code>.
            The correct property name is <strong><code>state</code></strong>.
          </p>
        </div>

        <div class="callout info">
          <p><strong>Why check both <code>!fetcher.data</code> and <code>fetcher.state === "idle"</code>?</strong></p>
          <ul>
            <li>Avoid repeated loading when data already exists</li>
            <li>Avoid calling <code>load</code> while a request is already in progress</li>
          </ul>
        </div>
      </section>

      <section>
        <h2>ğŸ§ª Debugging tip: log fetcher data</h2>
        <p>
          The transcript logs <code>fetcher.data</code> to confirm the menu is actually loaded.
          If you see <code>undefined</code> forever, check the state property name and the route path passed to <code>load</code>.
        </p>

        <pre><code>// Debug (temporary)
console.log(fetcher.data);
</code></pre>

        <div class="callout ok">
          <p><strong>Expected</strong></p>
          <p>
            After a moment, <code>fetcher.data</code> should contain the menu items array.
          </p>
        </div>
      </section>

      <section>
        <h2>ğŸ• Step 3: Attach ingredients to each order item</h2>
        <p>
          The order items contain <code>pizzaId</code>. The menu items contain <code>id</code> (or similar). You match them and
          pass only the ingredient list to the child component.
        </p>

        <pre><code>// Order.jsx (conceptual) â€” when rendering items
&lt;OrderItem
  item={item}
  ingredients={
    fetcher.data
      ?.find((el) =&gt; el.id === item.pizzaId)
      ?.ingredients ?? []
  }
  isLoadingIngredients={fetcher.state === "loading"}
/&gt;
</code></pre>

        <div class="callout warn">
          <p><strong>ID mismatch reminder</strong></p>
          <p>
            Menu uses <code>id</code>, Order item uses <code>pizzaId</code>. Be explicit in your comparison:
            <code>el.id === item.pizzaId</code>.
          </p>
        </div>

        <div class="callout info">
          <p><strong>Why <code>?? []</code>?</strong></p>
          <p>
            At first render, <code>fetcher.data</code> may still be missing.
            Returning <code>[]</code> prevents errors like calling <code>join()</code> on <code>undefined</code>.
          </p>
        </div>
      </section>

      <section>
        <h2>ğŸ§± Step 4: Render the ingredients in the child component</h2>
        <p>
          The transcript adds a small paragraph under the main item info.
          It shows â€œLoadingâ€¦â€ while fetcher is loading, otherwise it joins the ingredient array.
        </p>

        <pre><code>// OrderItem.jsx (conceptual)
function OrderItem({ item, ingredients, isLoadingIngredients }) {
  return (
    &lt;li className="space-y-1"&gt;
      &lt;div&gt;{/* existing order item UI */}&lt;/div&gt;

      &lt;p className="text-sm italic text-stone-500"&gt;
        {isLoadingIngredients ? "Loading..." : ingredients.join(", ")}
      &lt;/p&gt;
    &lt;/li&gt;
  );
}
</code></pre>

        <div class="callout ok">
          <p><strong>Result</strong></p>
          <p>
            Each ordered pizza now displays its ingredient list, even though you never navigated to the Menu page.
          </p>
        </div>
      </section>

      <section>
        <h2>ğŸ•³ï¸ Subtle bug: state is idle but data is still missing</h2>
        <p>
          The transcript hits an important edge case:
        </p>
        <ul>
          <li>At the very beginning, <code>fetcher.state</code> is <code>"idle"</code>.</li>
          <li>But that does <strong>not</strong> guarantee <code>fetcher.data</code> exists yet.</li>
        </ul>

        <div class="callout warn">
          <p><strong>Symptom</strong></p>
          <p>
            <code>ingredients.join(", ")</code> throws an error because <code>ingredients</code> is undefined.
          </p>
        </div>

        <p>
          The solution used in the lecture is to ensure that when menu data is missing, you pass an empty array:
          <code>?? []</code>.
        </p>

        <pre><code>// Safe ingredients prop
const ingredients =
  fetcher.data
    ?.find((el) =&gt; el.id === item.pizzaId)
    ?.ingredients ?? [];
</code></pre>
      </section>

      <section>
        <h2>ğŸ§¯ Common mistakes and quick fixes</h2>
        <ul>
          <li>
            âŒ <strong>Nothing loads</strong>
            <div class="callout"><strong>Fix:</strong> confirm you used <code>fetcher.state</code> (not <code>status</code>) and the route path is correct in <code>fetcher.load("/menu")</code>.</div>
          </li>
          <li>
            âŒ <strong>Console shows undefined forever</strong>
            <div class="callout"><strong>Fix:</strong> ensure the Menu route actually has a loader and that the path you pass to <code>load</code> matches your route config.</div>
          </li>
          <li>
            âŒ <strong>Crash: cannot read property 'join' of undefined</strong>
            <div class="callout"><strong>Fix:</strong> pass <code>ingredients ?? []</code> and/or render fallback text when ingredients are missing.</div>
          </li>
          <li>
            âŒ <strong>Wrong ingredients for the item</strong>
            <div class="callout"><strong>Fix:</strong> match IDs correctly: <code>menuItem.id === orderItem.pizzaId</code>.</div>
          </li>
        </ul>
      </section>

      <section>
        <h2>ğŸ§ª Mini-quiz (for retention)</h2>
        <ol>
          <li>What does <code>useFetcher</code> allow you to do that normal navigation does not?</li>
          <li>Where is the loaded data stored?</li>
          <li>What are the possible <code>fetcher.state</code> values?</li>
          <li>Why do we pass <code>?? []</code> as a fallback for ingredients?</li>
          <li>How do you match menu data to an order item?</li>
        </ol>
      </section>

      <section>
        <h2>ğŸ§¾ Quick recap</h2>
        <ul>
          <li>ğŸ§² Use <code>useFetcher()</code> to load data from another route without navigating</li>
          <li>â±ï¸ Fetch on mount: <code>useEffect</code> + <code>fetcher.load("/menu")</code></li>
          <li>âœ… Guard fetch: only when <code>!fetcher.data</code> and <code>fetcher.state === "idle"</code></li>
          <li>ğŸ• Enrich order items by finding menu item with matching <code>id</code>/<code>pizzaId</code></li>
          <li>ğŸ›¡ï¸ Avoid crashes by returning <code>[]</code> when data isn't ready</li>
          <li>ğŸ‘€ Display ingredients or â€œLoadingâ€¦â€ depending on <code>fetcher.state</code></li>
        </ul>
      </section>
    </main>
  </div>
</body>
</html>
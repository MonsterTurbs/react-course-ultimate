

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>React Study Guide â€” Introducing useRef (Refs vs State)</title>
  <style>
    :root{
      --bg:#ffffff;
      --text:#111111;
      --muted:#555555;
      --border:#e6e6e6;
      --panel:#fafafa;
      --code:#0b0f19;
      --codeText:#e6edf3;
      --ok:#0a7a2f;
      --warn:#8a5a00;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }

    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: Arial, Helvetica, sans-serif;
      line-height:1.6;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* Single-column page */
    .page{
      max-width: 940px;
      margin: 0 auto;
      padding: 28px 22px;
    }

    header{
      border:1px solid var(--border);
      background:var(--panel);
      border-radius:12px;
      padding:18px 18px 14px;
      margin-bottom:16px;
    }

    h1{
      font-size: 22px;
      line-height:1.25;
      margin:0 0 8px;
      letter-spacing: .2px;
    }

    .subtitle{
      margin:0;
      color:var(--muted);
      font-size: 13.5px;
    }

    .meta{
      margin-top:10px;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      color:var(--muted);
      font-size:12.5px;
    }

    .chip{
      border:1px solid var(--border);
      background:#fff;
      padding:4px 9px;
      border-radius: 999px;
      display:inline-flex;
      align-items:center;
      gap:6px;
      white-space:nowrap;
    }

    section{
      border:1px solid var(--border);
      border-radius:12px;
      padding:16px 16px 12px;
      margin: 14px 0;
      background:#fff;
      page-break-inside: avoid;
    }

    h2{
      font-size: 16.5px;
      margin:0 0 10px;
      line-height:1.25;
    }

    h3{
      font-size: 14.5px;
      margin: 12px 0 8px;
      line-height:1.25;
    }

    p{ margin: 8px 0; }
    ul{ margin: 8px 0 10px 22px; }
    li{ margin: 6px 0; }

    .callout{
      border-left: 4px solid var(--border);
      background: var(--panel);
      padding: 10px 12px;
      border-radius: 10px;
      margin: 10px 0;
    }

    .callout strong{ display:inline-block; margin-right:6px; }

    .rule{
      border: 1px dashed var(--border);
      background:#fff;
      border-radius:12px;
      padding: 12px;
      margin: 10px 0;
    }

    .compare{
      width:100%;
      border-collapse: collapse;
      margin: 10px 0 4px;
      font-size: 13.5px;
    }
    .compare th,
    .compare td{
      border:1px solid var(--border);
      padding: 10px 10px;
      vertical-align: top;
    }
    .compare th{
      background: var(--panel);
      text-align:left;
      font-weight:700;
    }

    pre{
      background: var(--code);
      color: var(--codeText);
      padding: 12px 12px;
      border-radius: 10px;
      overflow:auto;
      margin: 10px 0;
      font-size: 12.5px;
      line-height:1.5;
      tab-size: 2;
    }

    code{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .muted{ color:var(--muted); }
    .ok{ color: var(--ok); font-weight:700; }
    .warn{ color: var(--warn); font-weight:700; }

    /* Print */
    @page { size: A4; margin: 16mm; }

    @media print {
      body{ -webkit-print-color-adjust: exact; print-color-adjust: exact; }
      .page{ max-width: none; margin:0; padding:0; }
      header, section{ border-color:#cfcfcf; }
      pre{ overflow: visible; white-space: pre-wrap; word-wrap: break-word; }
      a{ color: inherit; text-decoration: none; }
    }
  </style>
</head>
<body>
  <main class="page">

    <header>
      <h1>ğŸ§  React Study Guide: Introducing <code>useRef</code> (Refs vs State)</h1>
      <p class="subtitle">A ref is like a small â€œboxâ€ that can store a value across rendersâ€”without causing a re-render when it changes.</p>
      <div class="meta">
        <span class="chip">ğŸ§· Hook: <strong>useRef</strong></span>
        <span class="chip">ğŸ¯ Use case #1: remember values across renders</span>
        <span class="chip">ğŸ¯ Use case #2: store/select DOM elements</span>
      </div>
    </header>

    <section>
      <h2>ğŸ§· What is a ref (in simple words)?</h2>
      <p><strong>Ref</strong> stands for <strong>reference</strong>. Think of it as:</p>
      <ul>
        <li>ğŸ“¦ a small container/box that React keeps <strong>the same between renders</strong></li>
        <li>ğŸ” you can put <strong>any data</strong> inside it</li>
        <li>ğŸ§  React â€œremembersâ€ that value for the component</li>
      </ul>

      <div class="callout">
        <strong>Technical definition:</strong> <code>useRef</code> returns an object with a mutable <code>.current</code> property.
      </div>

      <pre><code>const ref = useRef(23);

console.log(ref.current); // 23
ref.current = 1000;
console.log(ref.current); // 1000</code></pre>

      <p class="muted">Unlike most React data flows, <code>.current</code> is mutable (you can change it directly).</p>
    </section>

    <section>
      <h2>âœ¨ The special property: persisted across renders</h2>
      <p>Refs are persisted across renders, meaning:</p>
      <ul>
        <li>ğŸ” your component can re-render many times</li>
        <li>ğŸ§· but <code>ref.current</code> keeps the same value unless you change it</li>
      </ul>

      <div class="callout">
        <strong>Feels like state, butâ€¦</strong> changing a ref does <em>not</em> re-render the component.
      </div>
    </section>

    <section>
      <h2>âœ… Two big use cases for <code>useRef</code></h2>

      <div class="rule">
        <h3>1) ğŸ§  â€œRememberâ€ a value between renders (without re-rendering)</h3>
        <p>Great for values that should be preserved over time but do not belong in the UI output.</p>
        <ul>
          <li>â®ï¸ preserving the <strong>previous state</strong></li>
          <li>â±ï¸ storing an ID from <code>setTimeout</code> / <code>setInterval</code></li>
        </ul>
      </div>

      <div class="rule">
        <h3>2) ğŸ¯ Store/select DOM elements (the most important use)</h3>
        <p>This is the React-friendly alternative to <code>document.querySelector</code>.</p>
        <ul>
          <li>ğŸ§· attach a ref to an element in JSX</li>
          <li>ğŸ¯ access the real DOM node later (usually inside effects or handlers)</li>
          <li>âœ… no need to add classes/IDs just for selection</li>
        </ul>

        <pre><code>const inputEl = useRef(null);

useEffect(() =&gt; {
  inputEl.current?.focus();
}, []);

return &lt;input ref={inputEl} className="search" /&gt;;</code></pre>

        <p class="muted">(The next lecture typically shows this exact pattern for focusing the search input on mount.)</p>
      </div>
    </section>

    <section>
      <h2>ğŸš¦ Rule of thumb: ref vs state</h2>
      <p>Use this simple decision rule:</p>
      <ul>
        <li class="ok">âœ… Use <strong>state</strong> when the value should change what the user sees (UI output).</li>
        <li class="ok">âœ… Use a <strong>ref</strong> when the value should be remembered but should NOT trigger a re-render.</li>
      </ul>

      <div class="callout">
        <strong>Quick check:</strong> â€œDo I need the UI to update when this value changes?â€ If yes â†’ state. If no â†’ ref.
      </div>
    </section>

    <section>
      <h2>ğŸ†š Refs vs State (key differences)</h2>

      <table class="compare" aria-label="Refs vs State">
        <thead>
          <tr>
            <th>Feature</th>
            <th>ğŸ§© State (<code>useState</code>)</th>
            <th>ğŸ§· Ref (<code>useRef</code>)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Persisted across renders?</strong></td>
            <td>âœ… Yes</td>
            <td>âœ… Yes</td>
          </tr>
          <tr>
            <td><strong>Causes re-render when updated?</strong></td>
            <td>âœ… Yes</td>
            <td>âŒ No</td>
          </tr>
          <tr>
            <td><strong>Mutable?</strong></td>
            <td>âŒ No (treat as immutable)</td>
            <td>âœ… Yes (<code>ref.current</code> is mutable)</td>
          </tr>
          <tr>
            <td><strong>Update is async?</strong></td>
            <td>âœ… Often async/batched (new value not immediately available)</td>
            <td>âŒ No (you can read <code>.current</code> immediately after writing)</td>
          </tr>
          <tr>
            <td><strong>Best forâ€¦</strong></td>
            <td>UI data that should re-render</td>
            <td>DOM nodes & non-UI data to remember</td>
          </tr>
        </tbody>
      </table>

      <div class="callout">
        <strong>Big takeaway:</strong> Refs are like state with â€œless powerâ€ â€” they remember values but donâ€™t update the UI.
      </div>
    </section>

    <section>
      <h2>âš ï¸ Important discipline: donâ€™t use refs in render logic</h2>
      <p>Just like state, you generally should not read/write refs during render in a way that creates side effects.</p>
      <ul>
        <li class="warn">âš ï¸ Avoid mutating <code>ref.current</code> during render</li>
        <li>âœ… Prefer mutating refs inside <strong>event handlers</strong> or <strong>effects</strong></li>
      </ul>

      <pre><code>// âœ… Good: side effects belong in effects/handlers
useEffect(() =&gt; {
  timerId.current = window.setTimeout(() =&gt; {
    // ...
  }, 1000);
}, []);</code></pre>

      <p class="muted">Refs are typically used â€œbehind the scenesâ€ (effects/handlers), not as direct display data in JSX.</p>
    </section>

    <section>
      <h2>ğŸ“ Mini practice (quick check)</h2>
      <ul>
        <li>âœ… If you update a ref, why doesnâ€™t the UI re-render?</li>
        <li>âœ… Name 2 values that are good candidates for refs (not state).</li>
        <li>âœ… What goes wrong when you use <code>document.querySelector</code> everywhere?</li>
      </ul>
    </section>

    <section>
      <h2>ğŸ“Œ Key takeaways</h2>
      <ul>
        <li>ğŸ§· <code>useRef</code> returns an object with a mutable <code>.current</code> property.</li>
        <li>ğŸ” Refs persist across renders, like state.</li>
        <li>ğŸš« Updating refs does not re-render the component.</li>
        <li>ğŸ¯ Best use: store/select DOM elements (React-friendly alternative to querying the document).</li>
        <li>ğŸ§  Use state for UI output; use refs for â€œrememberedâ€ values not meant to re-render the UI.</li>
      </ul>
    </section>

  </main>
</body>
</html>